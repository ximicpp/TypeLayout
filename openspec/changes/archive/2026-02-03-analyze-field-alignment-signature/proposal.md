# Change: Analyze and Improve Field Alignment in Signatures

## Why

当前的签名格式中，每个字段的类型信息都包含 `[s:SIZE,a:ALIGN]` 后缀，例如：

```
@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]
```

这导致了几个问题：
1. **冗余信息**：对于基本类型如 `i32`，其 size=4、align=4 是固定的、可推导的
2. **签名膨胀**：每个字段增加 ~9 个字符的冗余信息
3. **一致性疑问**：字段级别的对齐信息 vs 结构体级别的对齐信息，哪个更有价值？

## What Changes

**分析阶段**（本提案）：
- 分析当前字段对齐信息的必要性和冗余度
- 确定哪些场景下字段级对齐信息是必需的
- 提出签名格式优化方案

**待确认的改进方向**：
- [ ] 移除基本类型的 `[s:,a:]` 后缀
- [ ] 保留结构体类型的 `[s:,a:]` 信息
- [ ] 对于特殊对齐（alignas）保留对齐信息
- [ ] 评估对二进制兼容性检测的影响

## Impact

- Affected specs: `signature`
- Affected code: None (analysis only)

---

## Analysis Results

### 核心发现：偏移量已隐含对齐结果

当前签名格式：
```
[64-le]struct[s:16,a:8]{@0[id_]:u64[s:8,a:8],@8[active_]:bool[s:1,a:1]}
```

**关键洞察**：
- **偏移量 `@8` 已经反映了对齐的结果** - `bool` 只需要 1 字节，但它在 `@8`，说明前面有 7 字节 padding
- **`s:16` 反映了尾部 padding** - `active_` 只占 1 字节（@8），但总大小是 16（为了 8 字节对齐）
- **布局不兼容必然导致偏移量不同** → 签名自然不匹配

### 冗余度分析

| 信息 | 来源 | 冗余？ | 保留原因 |
|------|------|--------|----------|
| `@N` 偏移量 | 必需 | ❌ | 直接反映布局 |
| `s:SIZE` 总大小 | 必需 | ❌ | 检测尾部 padding |
| `a:ALIGN` 对齐 | 可推导 | ⚠️ | 自文档性 |
| `[s:N,a:M]` 字段 | 可推导 | ⚠️ | 调试友好 |

### 验证场景

1. **同平台不同编译选项**：`@4` vs `@1` (packed) → 偏移量不同 ✅
2. **跨平台 LP64/LLP64**：`long` 大小不同 → 偏移量/大小不同 ✅
3. **alignas 特殊对齐**：`s:8,a:4` vs `s:16,a:16` → 大小/对齐不同 ✅

### 决定：保留现状

**理由**：
1. **自文档性**：签名包含完整信息，无需查表推导
2. **调试友好**：一眼可见每个字段的实际布局细节
3. **未来扩展**：为可能的扩展保留空间
4. **兼容性**：无需破坏现有使用者的期望

冗余的字符开销是可接受的代价。

---

## Original Analysis Questions

1. **字段对齐信息何时必需？**
   - 当字段类型有非默认对齐时（alignas）
   - 当需要验证 padding 时
   - 当字段类型本身是复合类型时

2. **字段对齐信息何时冗余？**
   - 基本类型（i8, i16, i32, i64, f32, f64 等）
   - 指针类型（平台相关但可推导）
   - 枚举类型（从底层类型推导）

3. **优化后的签名格式草案**：
   ```
   // 当前格式（冗余）
   struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}
   
   // 优化格式 A：移除基本类型的 size/align
   struct[s:8,a:4]{@0[x]:i32,@4[y]:i32}
   
   // 优化格式 B：仅在非默认对齐时标注
   struct[s:8,a:4]{@0[x]:i32,@4[y]:i32}
   struct[s:32,a:16]{@0[data]:i32[a:16],@16[value]:i32}  // 特殊对齐保留
   ```
