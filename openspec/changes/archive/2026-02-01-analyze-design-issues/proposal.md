# Change: 分析方案设计问题

## Why
TypeLayout 的主要用途是编译时内存布局验证，用于：
1. **二进制协议验证** - 确保网络协议结构在发送/接收端一致
2. **跨平台序列化** - 验证类型在不同平台上的布局兼容性
3. **共享内存验证** - 确保进程间共享的数据结构布局匹配
4. **ABI 兼容性检查** - 检测库升级时的二进制接口变化

需要分析当前设计是否真正满足这些核心用途，识别潜在的设计缺陷和改进机会。

## What Changes
- 分析签名格式设计对核心用例的适用性
- 识别跨平台/跨编译器场景的限制
- 评估 API 设计的易用性和正确性
- 提出改进建议

## Impact
- Affected specs: 新建 `design-issues`
- 这是一个分析性 proposal，不涉及代码修改

## 分析维度

### 1. 签名格式设计问题

#### ~~问题 1.1: 架构前缀绑定过紧~~ [已解决 - 设计合理]
**现状**: 签名包含 `[64-le]` 架构前缀（仅包含位数和字节序，不含 OS 信息）

**澄清**: 
- 同架构跨操作系统（如 Win64-le vs Linux64-le）签名**相同** ✅
- 架构前缀是必要的安全措施，用于防止 32 位与 64 位的误匹配
- 当类型包含指针时，32 位与 64 位布局确实不同，签名不同是正确行为

**结论**: 当前设计合理，无需修改

#### 问题 1.2: 成员名称包含在签名中
**现状**: 签名包含字段名 `{@0[x]:i32[s:4,a:4]}`
**问题**:
- 字段名重命名会破坏签名匹配，但实际布局并未改变
- 对于 ABI 兼容性检查，名称变化**不应该**导致不兼容
- 增加了签名长度和哈希碰撞风险

**建议**: 提供 `get_structural_layout<T>()` 只包含偏移和类型，不含名称

#### 问题 1.3: 缺少版本控制
**现状**: 签名格式没有版本标识
**问题**:
- 如果未来签名格式改变，旧签名与新签名无法区分
- 可能导致跨版本使用时的兼容性问题

**建议**: 在签名开头添加版本标识 `v1:[64-le]...`

### 2. 跨平台场景限制

#### 问题 2.1: 无法比较不同平台的签名
**场景**: 服务端运行在 64 位 Linux，客户端运行在 32 位嵌入式系统
**问题**: 
- 两边生成的签名必然不同（架构前缀不同）
- 但如果数据只使用 int32_t、uint64_t 等固定大小类型，**实际上是兼容的**
- 当前设计无法支持这种跨平台验证

**建议**: 提供 `is_layout_compatible_cross_platform<T>()` 检查数据部分是否兼容

#### 问题 2.2: 指针成员的处理
**现状**: 指针被标记为 `ptr` 但大小依赖平台
**问题**:
- 包含指针的结构体不应该用于跨平台序列化
- 但当前只在 `is_portable()` 中检查，签名仍然生成

**建议**: 对包含指针的类型生成警告签名或特殊标记

### 3. API 设计问题

#### 问题 3.1: TYPELAYOUT_BIND 宏的局限性
**现状**: `TYPELAYOUT_BIND(Type, "literal string")`
**问题**:
- 必须硬编码平台特定的签名字符串
- 在跨平台代码中需要条件编译
- 签名字符串很长，容易出错

**示例问题**:
```cpp
// 必须为每个平台写不同的签名
#if defined(__LP64__)
TYPELAYOUT_BIND(Point, "[64-le]struct...");
#else
TYPELAYOUT_BIND(Point, "[32-le]struct...");
#endif
```

**建议**: 提供基于哈希的绑定宏 `TYPELAYOUT_BIND_HASH(Type, hash_value)`

#### 问题 3.2: 缺少运行时验证支持
**场景**: 读取文件/网络数据时验证布局
**问题**: 
- 当前 API 主要面向编译时
- 缺少将签名/哈希嵌入二进制数据并在运行时验证的支持

**建议**: 添加 `runtime_verify<T>(const void* header)` 函数

#### 问题 3.3: 错误信息不友好
**现状**: 签名不匹配时，static_assert 只显示 "Layout mismatch for Type"
**问题**: 无法直观看到实际签名与期望签名的差异

**建议**: 改进编译错误信息，显示两个签名的对比

### 4. 哈希设计问题

#### 问题 4.1: 128 位验证可能过度
**现状**: 使用 FNV-1a + DJB2 双哈希
**问题**: 
- 对于大多数用例，单个 64 位哈希已经足够
- 双哈希增加了计算复杂度和存储需求
- 真正需要的是**更好的碰撞检测**，而非更长的哈希

**建议**: 默认使用单哈希，双哈希作为可选的严格模式

#### 问题 4.2: 哈希不包含签名长度（潜在）
**需验证**: 当前实现是否考虑了签名长度
**问题**: 如果两个不同长度的字符串产生相同哈希，可能导致误判

### 5. 核心用例验证

| 用例 | 当前支持度 | 主要问题 |
|------|-----------|----------|
| 同平台 ABI 验证 | ✅ 良好 | 字段名敏感 |
| 跨平台数据兼容性（同架构） | ✅ 良好 | 无（Win64-le = Linux64-le） |
| 网络协议验证 | ⚠️ 部分 | 缺少运行时验证 |
| 共享内存验证 | ✅ 良好 | - |
| 库 ABI 升级检查 | ⚠️ 部分 | 名称变更敏感 |
