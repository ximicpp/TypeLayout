## Context

Boost.TypeLayout 承诺三大核心价值 V1/V2/V3，它们构成了整个库的理论基石。
本文档分析这些承诺的数学正确性、边界条件和工程价值。

## Goals / Non-Goals

- Goals:
  - 证明 V1/V2/V3 在已声明假设下的正确性
  - 识别所有边界条件和已知反例
  - 评估设计哲学的利弊
  - 明确与竞品的差异化定位

- Non-Goals:
  - 不修改核心签名引擎代码
  - 不引入新 API
  - 不改变现有行为

## Decisions

### V1 正确性分析: `layout_sig(T) == layout_sig(U) ⟹ memcmp-compatible(T, U)`

**正确性论证:**

layout_sig 编码了以下完整信息:
1. 架构前缀 `[64-le]` — 指针宽度 + 字节序
2. `s:SIZE, a:ALIGN` — sizeof 和 alignof
3. `@OFFSET:type_sig` — 每个叶字段的绝对字节偏移 + 类型签名
4. `,vptr` — 多态标记

如果两个签名完全相同，则:
- sizeof(T) == sizeof(U) (大小一致)
- alignof(T) == alignof(U) (对齐一致)
- 每个字节偏移处的字段类型完全相同
- 隐含推论: padding 字节的位置和数量完全一致

因此两个类型的内存布局是字节对字节相同的 → `memcmp(t, u, sizeof(T)) == 0` 当且仅当对应字段值相同。

**边界条件 (V1 成立但需注意):**

| 场景 | V1 是否成立 | 注意事项 |
|------|------------|---------|
| 固定宽度整数 POD | ✅ 完全成立 | 最安全的场景 |
| IEEE 754 浮点 | ✅ 成立 | 前提: 双方平台均为 IEEE 754 |
| 含指针类型 | ✅ 布局成立 | 但指针值不可跨地址空间传输 |
| 含位域类型 | ⚠️ 条件成立 | 同编译器同平台保证成立；跨编译器位域顺序是 impl-defined |
| 含 `wchar_t`/`long` | ✅ 不适用 | 不同平台签名自然不同，V1 不会给出假阳性 |
| 含 `long double` | ✅ 不适用 | 同上，大小不同签名不同 |
| padding 字节值 | ✅ 布局成立 | 但 padding 字节内容是未初始化的，memcmp 可能不等 |

**V1 的保守性:**

V1 是单向蕴含 (⟹ 而非 ⟺)，这是有意的保守设计:
- `int[3]` 和 `struct { int a,b,c; }` 字节布局相同，但签名不同
- 这不是缺陷——array 保持语义边界使签名更精确

**结论:** V1 在已声明假设 (IEEE 754, 同 endianness) 下严格正确。保守性是一种安全性——永远不会出现"签名匹配但布局不同"的假阳性。

---

### V2 正确性分析: `def_sig(T) == def_sig(U) ⟹ identical structure`

**区分力分析:**

Definition 签名在 Layout 基础上增加:
1. 字段名 `[name]`
2. 继承结构 `~base<ns::Name>:record{...}`
3. 多态标记 `polymorphic`
4. 枚举限定名 `enum<ns::Color>`
5. 命名空间路径 (完全限定名)

**V2 能区分的场景:**

| 场景 | Layout 签名 | Definition 签名 | 区分力 |
|------|------------|----------------|-------|
| 字段名不同 | 相同 | 不同 ✅ | `{x,y}` vs `{a,b}` |
| 继承 vs 扁平 | 相同 | 不同 ✅ | `Derived:Base` vs `Flat` |
| 不同命名空间基类 | 相同 | 不同 ✅ | `ns1::Tag` vs `ns2::Tag` |
| 不同枚举名 | 相同 | 不同 ✅ | `Color` vs `Shape` |
| 虚继承 vs 普通继承 | 不同 | 不同 ✅ | 偏移不同 |
| 多态 vs 非多态 | 不同 | 不同 ✅ | vptr 标记 |

**V2 的极限 (无法区分的场景):**

| 场景 | 能否区分 | 原因 |
|------|---------|------|
| 类型自身名称不同 | ❌ | 设计决定: 结构分析不含类型名 |
| 同名同结构不同语义 | ❌ | 类型签名不编码语义信息 |
| `const int` vs `int` | ❌ | cv 限定符在内存布局上无差异 |

**结论:** V2 在结构分析范畴内已达到最大区分力。不包含类型自身名称是一个明确的设计权衡——使 TypeLayout 成为结构等价检测工具而非类型身份验证工具。

---

### V3 正确性分析: `def_match(T, U) ⟹ layout_match(T, U)`

**代数性质:**

这是 V3 的投影 (projection) 关系。Definition 签名可以视为 Layout 签名的一个细化 (refinement):

```
Definition 信息 = Layout 信息 + 字段名 + 继承结构 + 限定名
```

因此 Definition 匹配 → Layout 信息必然匹配 → Layout 签名匹配。

这是一个代数上的平凡推论——信息多的等价蕴含信息少的等价。但它有实际工程价值:
- 如果你验证了 `def_match`，你就同时验证了 `layout_match`，不需要两次检查
- 反之不成立: `layout_match` 不蕴含 `def_match`（如继承 vs 扁平）

**结论:** V3 在数学上是 trivially correct（平凡正确）。它的价值在于为用户提供清晰的层级选择指导——选择更严格的 Definition 自动获得 Layout 兼容性。

---

### 设计哲学: 结构分析 vs 名义分析

**选择结构分析的理由:**

| 考量 | 结构分析 (TypeLayout 方式) | 名义分析 (包含类型名) |
|------|--------------------------|---------------------|
| 跨编译单元 | ✅ 不同名字相同结构可检测 | ❌ 名字不同即判异 |
| ODR 检测 | ✅ 相同名字不同结构可检测 | 部分 (需额外检查) |
| 使用场景 | "这两个类型能 memcpy 吗?" | "这两个类型是同一个吗?" |
| 假阳性 | 极低 (保守方向) | 低但不同维度 |
| 假阴性 | 有 (int[3] vs int,int,int) | 极低 |

**权衡结论:** 对于 TypeLayout 的核心使用场景（IPC、共享内存、跨平台兼容），结构分析是正确选择——用户关心的是"能否安全传输数据"而非"类型名是否相同"。

---

### 与竞品对比

| 维度 | TypeLayout | protobuf | FlatBuffers | pahole/DWARF |
|------|-----------|----------|-------------|--------------|
| 分析时机 | 编译时 | 编译时 (schema) | 编译时 | 运行时 |
| 运行时开销 | 零 | 编解码开销 | 接近零 | N/A |
| 跨语言 | C++ only | 多语言 | 多语言 | C/C++ |
| 需要 schema | 不需要 | 需要 .proto | 需要 .fbs | 不需要 |
| 版本化支持 | 无 (静态快照) | 完善 | 完善 | 无 |
| 主要价值 | **验证**已有类型布局 | **生成**序列化代码 | **生成**零拷贝访问代码 | **调试**布局问题 |

**差异化定位:** TypeLayout 不是 protobuf 的替代品，而是互补品。protobuf 解决"如何序列化"，TypeLayout 解决"是否需要序列化"——当签名匹配时，你可以跳过序列化直接 memcpy。

## Risks / Trade-offs

- V1 的 padding 字节问题: memcmp 等价不等于 memcpy 安全（padding 值未定义）
  → 缓解: 文档明确说明 "memcmp-compatible" 指布局兼容，非比特精确相等
- V2 不含类型名: 两个完全不同语义但碰巧结构相同的类型会被视为匹配
  → 缓解: 在实践中极少出现；用户应结合类型名手动验证语义

## Open Questions

- 是否需要引入 V4 "语义标注"层（用户可选的语义标签）？→ 暂不引入，保持简洁
- padding 初始化保证是否应该成为 V1 的假设之一？→ 记录但不改变保证
