## Context

TypeLayout 的架构由多个关键设计决策组成。本文档逐一分析每个决策的合理性，
论证当前选择是最优或至少是合理的。

## Goals / Non-Goals

- Goals:
  - 论证每个架构决策的必要性
  - 分析替代方案的劣势
  - 识别现有架构的性能边界

- Non-Goals:
  - 不改变现有架构
  - 不实现替代方案

## Decisions

### 决策 1: 为何是两层签名？（不是一层或三层）

**一层方案 (仅 Layout) 的不足:**

如果只有 Layout 签名，用户无法区分:
- 继承 vs 扁平结构 (字节相同但语义不同)
- 字段名变更 (重构后布局不变但 API 变了)
- 不同枚举类型 (底层类型相同但语义不同)

这些场景在 API 兼容性检查、序列化版本管理中至关重要。

**一层方案 (仅 Definition) 的不足:**

如果只有 Definition 签名，用户无法判断:
- "继承的 Derived 和扁平的 Flat 能否 memcpy？" → 不能直接回答
- 需要手动忽略结构差异去判断字节兼容性

**三层方案 (Layout + Definition + Semantic) 的问题:**

第三层"语义签名"需要用户主动标注语义信息，这:
- 增加用户负担 (违背"零注解"设计目标)
- 难以自动化 (P2996 无法推断语义)
- 收益有限 (名义分析已有其他工具解决)

**结论:** 两层是信息论上的最优平衡点——Layout 回答"能否 memcpy"，Definition 回答"结构是否一致"。两个问题覆盖了 95% 的实际使用场景。

---

### 决策 2: 为何两阶段管线？（Export + Check 分离）

**核心约束:** P2996 目前仅 Bloomberg Clang fork 支持。

**如果不分离 (单阶段方案):**
- Phase 2 (兼容检查) 也需要 P2996 编译器
- 用户无法在 MSVC/GCC 环境中运行兼容检查
- CI/CD 集成困难 (需要所有平台安装 P2996 工具链)

**两阶段分离的优势:**

| 维度 | 单阶段 | 两阶段 (当前) |
|------|--------|-------------|
| Phase 2 编译器要求 | P2996 Clang only | 任何 C++17 编译器 |
| CI/CD 集成 | 需要 P2996 在所有平台 | Phase 2 可在任何 CI 运行 |
| 签名可存储/传输 | ❌ 运行时生成 | ✅ .sig.hpp 可版本控制 |
| 历史比较 | ❌ 无法回溯 | ✅ 可比较不同提交的签名 |
| 增量验证 | ❌ 全量重新生成 | ✅ 只需重新导出变更平台 |

**反驳: "P2996 标准化后两阶段还有意义吗？"**

是的。即使 P2996 被所有编译器支持:
1. 签名文件 (.sig.hpp) 本身作为"布局快照"具有独立价值 (版本控制、审计)
2. Phase 2 的 C++17 要求使其可嵌入更老的代码库
3. 跨编译器比较 (GCC vs Clang) 仍需在不同工具链上分别导出

**结论:** 两阶段设计是 P2996 生态现状的最优解，且在 P2996 标准化后仍有持续价值。

---

### 决策 3: 为何 header-only + consteval？

**header-only 的理由:**
1. Boost 社区惯例 — 大多数 Boost 库是 header-only
2. 编译时计算不需要链接 — 所有结果在编译时产生
3. 简化集成 — 用户只需 `-I./include`，无需链接步骤
4. 跨平台一致性 — 无平台相关的二进制产物

**consteval 的理由:**
1. 零运行时开销 — 签名生成在编译时完成，运行时无任何计算
2. 安全性保证 — consteval 强制编译时求值，不可能意外变成运行时
3. static_assert 兼容 — 可直接在 static_assert 中使用
4. 编译器验证 — 所有偏移、大小由编译器的 P2996 API 提供，不是手算的

**替代方案 (constexpr) 的劣势:**
- constexpr 允许运行时求值，用户可能误以为有运行时开销
- consteval 更明确地表达"这只在编译时发生"的设计意图

**结论:** header-only + consteval 是 TypeLayout 使用场景 (编译时分析) 的自然选择。

---

### 决策 4: FixedString<N> 的性能边界

**为何选择 FixedString<N>:**
- C++26 consteval 不支持 `std::string` 的动态分配
- 需要编译时字符串连接、比较、存储
- FixedString<N> 是唯一可行的编译时字符串方案

**性能边界:**

| 操作 | 复杂度 | 瓶颈 |
|------|--------|------|
| `operator+` (连接) | O(N+M) 逐字符复制 | 大型签名的主要瓶颈 |
| fold expression 展开 | O(n×L) n=字段数, L=平均签名长 | 产生 O(n²L) 总复制量 |
| 100 字段结构体 | ~1800 字符签名 | 需要 `-fconstexpr-steps=3000000` |

**替代方案评估:**

| 方案 | 可行性 | 缺点 |
|------|--------|------|
| `std::string` (constexpr) | ❌ C++26 不支持 consteval 中使用 | N/A |
| 固定大缓冲区 `char[8192]` | ⚠️ 可行但浪费 | 小类型签名仅 ~50 字符，浪费 99% 空间 |
| 分段签名 (不连接) | ⚠️ 可行 | 比较逻辑复杂，失去人类可读性 |
| 哈希签名 | ⚠️ 可行 | 失去人类可读性和调试友好性 |

**结论:** FixedString<N> 是当前约束下的最佳选择。性能边界 (100 字段) 覆盖了绝大多数实际类型。超大型类型可通过 `-fconstexpr-steps` 编译选项支持。

## Risks / Trade-offs

- FixedString 连接的 O(n²) 开销在超大类型上可能导致编译缓慢
  → 缓解: 已记录步数限制和编译选项建议
- 两阶段管线增加了用户的操作步骤
  → 缓解: 提供了 CMake 模块和 GitHub Actions 工作流自动化

## Open Questions

- P2996 标准化后是否应该提供可选的"单阶段"模式？→ 可以考虑，但两阶段仍保留
- 是否应该探索 `constexpr std::string` (C++26 之后可能支持)？→ 跟踪标准进展
