= Shared Memory Example
:navtitle: Shared Memory

Using Boost.TypeLayout for safe inter-process communication via shared memory.

== The Challenge: Cross-Process Data Sharing

[IMPORTANT]
====
This example demonstrates **ðŸ”„ Cross-Process** data sharingâ€”one of the three boundaries where TypeLayout's core guarantee applies:

**Same Signature âŸº Same Memory Layout âŸº Safe to share raw bytes**

When two processes access the same memory region, they MUST agree on the exact byte layout. TypeLayout verifies this at compile time.
====

== Overview

Shared memory allows multiple processes to access the same memory region.
TypeLayout helps ensure all processes agree on the memory layout.

== Shared Memory Structure

=== Header with Version Info

[source,cpp]
----
#include <boost/typelayout.hpp>
#include <cstdint>
#include <array>
#include <atomic>

using namespace boost::typelayout;

// Shared memory region header
struct SharedHeader {
    std::array<char, 8> magic;       // "SHMEM001"
    std::uint32_t version;           // Structure version
    std::uint32_t header_size;       // Size of this header
    std::uint64_t layout_hash;       // Hash of data structure
    std::uint64_t data_offset;       // Offset to data section
    std::uint64_t data_size;         // Size of data section
    std::atomic<std::uint32_t> lock; // Simple spinlock
    std::uint32_t reserved;          // Padding
};

static_assert(is_serializable_v<SharedHeader, PlatformSet::current()>,
    "SharedHeader must be serializable for cross-process communication");

constexpr std::array<char, 8> SHMEM_MAGIC = 
    {'S', 'H', 'M', 'E', 'M', '0', '0', '1'};
----

=== Data Structure

[source,cpp]
----
// Shared data structure
struct SharedData {
    std::atomic<std::uint64_t> counter;
    std::atomic<std::uint64_t> timestamp;
    std::array<std::int32_t, 256> values;
    std::array<char, 1024> message;
};

static_assert(is_serializable_v<SharedData, PlatformSet::current()>,
    "SharedData must be serializable for cross-process communication");

constexpr auto SHARED_DATA_HASH = get_layout_hash<SharedData>();
----

== Shared Memory Manager

[source,cpp]
----
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdexcept>
#include <cstring>

class SharedMemoryManager {
    void* mapped_region_ = nullptr;
    std::size_t size_ = 0;
    int fd_ = -1;
    bool is_creator_ = false;
    
public:
    SharedMemoryManager() = default;
    ~SharedMemoryManager() { close(); }
    
    // Create new shared memory region
    template<Serializable DataT>
    DataT* create(const char* name) {
        constexpr std::size_t total_size = sizeof(SharedHeader) + sizeof(DataT);
        
        // Create shared memory object
        fd_ = shm_open(name, O_CREAT | O_RDWR | O_EXCL, 0666);
        if (fd_ == -1) {
            throw std::runtime_error("Failed to create shared memory");
        }
        
        // Set size
        if (ftruncate(fd_, total_size) == -1) {
            shm_unlink(name);
            throw std::runtime_error("Failed to set shared memory size");
        }
        
        // Map memory
        mapped_region_ = mmap(nullptr, total_size, 
            PROT_READ | PROT_WRITE, MAP_SHARED, fd_, 0);
        if (mapped_region_ == MAP_FAILED) {
            shm_unlink(name);
            throw std::runtime_error("Failed to map shared memory");
        }
        
        size_ = total_size;
        is_creator_ = true;
        
        // Initialize header
        auto* header = static_cast<SharedHeader*>(mapped_region_);
        header->magic = SHMEM_MAGIC;
        header->version = 1;
        header->header_size = sizeof(SharedHeader);
        header->layout_hash = get_layout_hash<DataT>();
        header->data_offset = sizeof(SharedHeader);
        header->data_size = sizeof(DataT);
        header->lock.store(0);
        
        // Initialize data
        auto* data = reinterpret_cast<DataT*>(
            static_cast<char*>(mapped_region_) + sizeof(SharedHeader));
        new (data) DataT{};  // Placement new for initialization
        
        return data;
    }
    
    // Open existing shared memory region
    template<Serializable DataT>
    DataT* open(const char* name) {
        // Open existing shared memory
        fd_ = shm_open(name, O_RDWR, 0666);
        if (fd_ == -1) {
            throw std::runtime_error("Failed to open shared memory");
        }
        
        // Get size
        struct stat sb;
        if (fstat(fd_, &sb) == -1) {
            throw std::runtime_error("Failed to get shared memory size");
        }
        
        // Map memory
        mapped_region_ = mmap(nullptr, sb.st_size,
            PROT_READ | PROT_WRITE, MAP_SHARED, fd_, 0);
        if (mapped_region_ == MAP_FAILED) {
            throw std::runtime_error("Failed to map shared memory");
        }
        
        size_ = sb.st_size;
        
        // Validate header
        auto* header = static_cast<SharedHeader*>(mapped_region_);
        
        if (header->magic != SHMEM_MAGIC) {
            close();
            throw std::runtime_error("Invalid shared memory magic");
        }
        
        // Critical: Verify layout compatibility
        if (header->layout_hash != get_layout_hash<DataT>()) {
            close();
            throw std::runtime_error(
                "Shared memory layout mismatch! "
                "The other process is using an incompatible structure version.");
        }
        
        return reinterpret_cast<DataT*>(
            static_cast<char*>(mapped_region_) + header->data_offset);
    }
    
    void close() {
        if (mapped_region_ && mapped_region_ != MAP_FAILED) {
            munmap(mapped_region_, size_);
            mapped_region_ = nullptr;
        }
        if (fd_ != -1) {
            ::close(fd_);
            fd_ = -1;
        }
    }
    
    static void unlink(const char* name) {
        shm_unlink(name);
    }
};
----

== Producer/Consumer Example

=== Producer Process

[source,cpp]
----
// producer.cpp
#include <iostream>
#include <chrono>
#include <thread>

int main() {
    SharedMemoryManager shm;
    
    try {
        std::cout << "Creating shared memory...\n";
        auto* data = shm.create<SharedData>("/my_shared_data");
        
        std::cout << "Layout hash: 0x" << std::hex 
                  << get_layout_hash<SharedData>() << std::dec << "\n";
        
        // Produce data
        for (int i = 0; i < 100; ++i) {
            // Simple spinlock
            while (data->counter.exchange(1) == 1) {
                std::this_thread::yield();
            }
            
            // Update data
            data->timestamp.store(
                std::chrono::system_clock::now().time_since_epoch().count());
            data->values[i % 256] = i * 10;
            
            std::snprintf(data->message.data(), data->message.size(),
                "Message #%d from producer", i);
            
            // Release lock
            data->counter.store(0);
            
            std::cout << "Produced: " << i << "\n";
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }
        
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << "\n";
        return 1;
    }
    
    std::cout << "Press Enter to cleanup...";
    std::cin.get();
    
    SharedMemoryManager::unlink("/my_shared_data");
    return 0;
}
----

=== Consumer Process

[source,cpp]
----
// consumer.cpp
#include <iostream>
#include <chrono>
#include <thread>

int main() {
    SharedMemoryManager shm;
    
    try {
        std::cout << "Opening shared memory...\n";
        auto* data = shm.open<SharedData>("/my_shared_data");
        
        std::cout << "Layout verified successfully!\n";
        std::cout << "Expected hash: 0x" << std::hex 
                  << get_layout_hash<SharedData>() << std::dec << "\n";
        
        // Consume data
        for (int i = 0; i < 50; ++i) {
            // Simple spinlock
            while (data->counter.exchange(1) == 1) {
                std::this_thread::yield();
            }
            
            // Read data
            auto timestamp = data->timestamp.load();
            std::string msg(data->message.data());
            
            // Release lock
            data->counter.store(0);
            
            std::cout << "Read: ts=" << timestamp << " msg=\"" << msg << "\"\n";
            std::this_thread::sleep_for(std::chrono::milliseconds(200));
        }
        
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << "\n";
        return 1;
    }
    
    return 0;
}
----

== Version Migration

=== Handling Layout Changes

[source,cpp]
----
// When you need to change the shared data structure:

// Version 1
struct SharedData_v1 {
    std::atomic<std::uint64_t> counter;
    std::array<std::int32_t, 256> values;
};

// Version 2 - added field
struct SharedData_v2 {
    std::atomic<std::uint64_t> counter;
    std::array<std::int32_t, 256> values;
    std::atomic<std::uint64_t> timestamp;  // New!
};

// Migration helper
template<typename NewT, typename OldT>
void migrate_shared_data(const char* name) {
    // Open with old layout
    SharedMemoryManager old_shm;
    auto* old_data = old_shm.open<OldT>(name);
    
    // Create new region
    SharedMemoryManager new_shm;
    auto* new_data = new_shm.create<NewT>((std::string(name) + "_v2").c_str());
    
    // Copy compatible fields
    new_data->counter.store(old_data->counter.load());
    std::copy(old_data->values.begin(), old_data->values.end(),
              new_data->values.begin());
    
    // Initialize new fields
    new_data->timestamp.store(0);
    
    // Swap regions
    // ... (coordinate with other processes)
}
----

== Cross-Platform Considerations

=== Windows Equivalent

[source,cpp]
----
#ifdef _WIN32
#include <windows.h>

class SharedMemoryManager {
    HANDLE mapping_ = nullptr;
    void* view_ = nullptr;
    
public:
    template<Serializable DataT>
    DataT* create(const wchar_t* name) {
        constexpr std::size_t size = sizeof(SharedHeader) + sizeof(DataT);
        
        mapping_ = CreateFileMappingW(
            INVALID_HANDLE_VALUE, nullptr,
            PAGE_READWRITE, 0, size, name);
        
        if (!mapping_) {
            throw std::runtime_error("Failed to create file mapping");
        }
        
        view_ = MapViewOfFile(mapping_, FILE_MAP_ALL_ACCESS, 0, 0, size);
        if (!view_) {
            CloseHandle(mapping_);
            throw std::runtime_error("Failed to map view");
        }
        
        // ... initialize header and data (same as POSIX)
        
        return static_cast<DataT*>(/* data offset */);
    }
    
    // ... similar open() implementation
};
#endif
----

== Best Practices

=== 1. Always Verify Layout on Open

[source,cpp]
----
// The layout hash check is critical!
if (header->layout_hash != get_layout_hash<DataT>()) {
    throw std::runtime_error("Layout mismatch");
}
----

=== 2. Include Version in Header

[source,cpp]
----
struct SharedHeader {
    std::uint32_t version;      // For migration
    std::uint64_t layout_hash;  // For verification
    // ...
};
----

=== 3. Use Atomic Operations

[source,cpp]
----
// All shared data should use atomics for thread safety
struct SharedData {
    std::atomic<std::uint64_t> counter;  // ï¿½?
    std::uint64_t unsafe_counter;        // ï¿½?Race condition!
};
----

=== 4. Test Layout Stability

[source,cpp]
----
// Regression test
TEST(SharedMemory, LayoutStable) {
    // Hash should match documented value
    EXPECT_EQ(get_layout_hash<SharedData>(), 0x1234567890abcdef);
}
----

== See Also

* xref:examples/network-protocol.adoc[Network Protocol Example]
* xref:examples/serialization.adoc[Serialization Example]
* xref:../user-guide/hash-verification.adoc[Hash Verification Guide]