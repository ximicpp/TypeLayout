= Serialization Example
:navtitle: Serialization

Using Boost.TypeLayout for safe binary serialization with layout verification.

== Overview

Binary serialization requires consistent memory layout between writer and reader.
TypeLayout ensures layout compatibility and detects format changes.

== Basic Serialization

=== File Header

[source,cpp]
----
#include <boost/typelayout.hpp>
#include <cstdint>
#include <array>
#include <fstream>
#include <span>

using namespace boost::typelayout;

// File format header
struct FileHeader {
    std::array<char, 4> magic;    // File type identifier
    std::uint32_t version;        // Format version
    std::uint64_t layout_hash;    // Hash of data structure
    std::uint64_t record_count;   // Number of records
    std::uint64_t data_offset;    // Offset to first record
};

static_assert(is_portable<FileHeader>(),
    "FileHeader must be portable for file compatibility");
----

=== Data Structure

[source,cpp]
----
// Record to be serialized
struct Record {
    std::uint64_t id;
    std::int32_t  value_a;
    std::int32_t  value_b;
    float         score;
    std::array<char, 32> name;
};

static_assert(is_portable<Record>(),
    "Record must be portable for serialization");

constexpr std::array<char, 4> FILE_MAGIC = {'R', 'E', 'C', 'D'};
constexpr std::uint32_t FORMAT_VERSION = 1;
constexpr auto RECORD_LAYOUT_HASH = get_layout_hash<Record>();
----

== Serializer Implementation

=== Writer

[source,cpp]
----
#include <vector>
#include <stdexcept>

class BinaryWriter {
    std::ofstream file_;
    std::uint64_t record_count_ = 0;
    
public:
    explicit BinaryWriter(const std::string& path)
        : file_(path, std::ios::binary)
    {
        if (!file_) {
            throw std::runtime_error("Failed to open file for writing");
        }
        
        // Write placeholder header (will update on close)
        FileHeader header{};
        header.magic = FILE_MAGIC;
        header.version = FORMAT_VERSION;
        header.layout_hash = RECORD_LAYOUT_HASH;
        header.record_count = 0;
        header.data_offset = sizeof(FileHeader);
        
        write_raw(header);
    }
    
    ~BinaryWriter() {
        finalize();
    }
    
    template<PortableType T>
    void write(const T& record) {
        write_raw(record);
        ++record_count_;
    }
    
    template<PortableType T>
    void write_all(std::span<const T> records) {
        for (const auto& r : records) {
            write(r);
        }
    }
    
    void finalize() {
        if (!file_.is_open()) return;
        
        // Update header with final count
        file_.seekp(0);
        FileHeader header{};
        header.magic = FILE_MAGIC;
        header.version = FORMAT_VERSION;
        header.layout_hash = RECORD_LAYOUT_HASH;
        header.record_count = record_count_;
        header.data_offset = sizeof(FileHeader);
        
        write_raw(header);
        file_.close();
    }
    
private:
    template<typename T>
    void write_raw(const T& data) {
        file_.write(reinterpret_cast<const char*>(&data), sizeof(T));
    }
};
----

=== Reader

[source,cpp]
----
class BinaryReader {
    std::ifstream file_;
    FileHeader header_;
    std::uint64_t current_record_ = 0;
    
public:
    explicit BinaryReader(const std::string& path)
        : file_(path, std::ios::binary)
    {
        if (!file_) {
            throw std::runtime_error("Failed to open file for reading");
        }
        
        // Read and validate header
        read_raw(header_);
        
        if (header_.magic != FILE_MAGIC) {
            throw std::runtime_error("Invalid file format (bad magic)");
        }
        
        if (header_.version != FORMAT_VERSION) {
            throw std::runtime_error(
                "Unsupported format version: " + 
                std::to_string(header_.version));
        }
        
        // Critical: Verify layout compatibility
        if (header_.layout_hash != RECORD_LAYOUT_HASH) {
            throw std::runtime_error(
                "Record layout mismatch! File was written with "
                "an incompatible Record structure.");
        }
        
        // Seek to data section
        file_.seekg(header_.data_offset);
    }
    
    std::uint64_t record_count() const { 
        return header_.record_count; 
    }
    
    template<PortableType T>
    bool read(T& record) {
        if (current_record_ >= header_.record_count) {
            return false;
        }
        
        read_raw(record);
        ++current_record_;
        return true;
    }
    
    template<PortableType T>
    std::vector<T> read_all() {
        std::vector<T> records;
        records.reserve(header_.record_count);
        
        T record;
        while (read(record)) {
            records.push_back(record);
        }
        
        return records;
    }
    
    void reset() {
        file_.seekg(header_.data_offset);
        current_record_ = 0;
    }
    
private:
    template<typename T>
    void read_raw(T& data) {
        file_.read(reinterpret_cast<char*>(&data), sizeof(T));
    }
};
----

== Complete Example

[source,cpp]
----
#include <iostream>
#include <cstring>

void write_example_data(const std::string& path) {
    std::cout << "Writing data...\n";
    
    BinaryWriter writer(path);
    
    // Write some records
    for (std::uint64_t i = 0; i < 100; ++i) {
        Record r{};
        r.id = i;
        r.value_a = static_cast<std::int32_t>(i * 10);
        r.value_b = static_cast<std::int32_t>(i * 20);
        r.score = static_cast<float>(i) / 100.0f;
        std::snprintf(r.name.data(), r.name.size(), "Record_%llu", i);
        
        writer.write(r);
    }
    
    std::cout << "Wrote 100 records\n";
    std::cout << "Record layout: " << get_layout_signature<Record>() << "\n";
}

void read_example_data(const std::string& path) {
    std::cout << "\nReading data...\n";
    
    BinaryReader reader(path);
    
    std::cout << "File contains " << reader.record_count() << " records\n";
    
    // Read first 5 records
    Record r;
    for (int i = 0; i < 5 && reader.read(r); ++i) {
        std::cout << "  Record " << r.id << ": " 
                  << r.name.data() << " score=" << r.score << "\n";
    }
}

int main() {
    const std::string filename = "test_data.bin";
    
    try {
        write_example_data(filename);
        read_example_data(filename);
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << "\n";
        return 1;
    }
    
    // Cleanup
    std::remove(filename.c_str());
    
    return 0;
}
----

== Version Migration

=== Schema Evolution

[source,cpp]
----
// Version 1 schema
struct Record_v1 {
    std::uint64_t id;
    std::int32_t  value;
    std::array<char, 32> name;
};

// Version 2 schema - added fields
struct Record_v2 {
    std::uint64_t id;
    std::int32_t  value_a;     // Renamed from 'value'
    std::int32_t  value_b;     // New field
    float         score;       // New field
    std::array<char, 32> name;
};

// Migration function
Record_v2 migrate_v1_to_v2(const Record_v1& old) {
    Record_v2 new_rec{};
    new_rec.id = old.id;
    new_rec.value_a = old.value;
    new_rec.value_b = 0;        // Default for new field
    new_rec.score = 0.0f;       // Default for new field
    new_rec.name = old.name;
    return new_rec;
}
----

=== Multi-Version Reader

[source,cpp]
----
class VersionedReader {
    std::ifstream file_;
    FileHeader header_;
    
public:
    explicit VersionedReader(const std::string& path)
        : file_(path, std::ios::binary)
    {
        file_.read(reinterpret_cast<char*>(&header_), sizeof(header_));
        
        if (header_.magic != FILE_MAGIC) {
            throw std::runtime_error("Invalid file format");
        }
    }
    
    std::vector<Record_v2> read_all_as_v2() {
        std::vector<Record_v2> results;
        file_.seekg(header_.data_offset);
        
        switch (header_.version) {
            case 1: {
                // Read v1 records and migrate
                Record_v1 r1;
                while (file_.read(reinterpret_cast<char*>(&r1), sizeof(r1))) {
                    results.push_back(migrate_v1_to_v2(r1));
                }
                break;
            }
            case 2: {
                // Read v2 records directly
                Record_v2 r2;
                while (file_.read(reinterpret_cast<char*>(&r2), sizeof(r2))) {
                    results.push_back(r2);
                }
                break;
            }
            default:
                throw std::runtime_error("Unsupported version");
        }
        
        return results;
    }
};
----

== Memory-Mapped I/O

For large files, use memory mapping:

[source,cpp]
----
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>

template<PortableType T>
class MappedRecordFile {
    void* mapped_ = nullptr;
    std::size_t size_ = 0;
    FileHeader* header_ = nullptr;
    T* records_ = nullptr;
    
public:
    explicit MappedRecordFile(const std::string& path) {
        int fd = open(path.c_str(), O_RDONLY);
        if (fd == -1) throw std::runtime_error("Failed to open file");
        
        struct stat sb;
        fstat(fd, &sb);
        size_ = sb.st_size;
        
        mapped_ = mmap(nullptr, size_, PROT_READ, MAP_PRIVATE, fd, 0);
        close(fd);
        
        if (mapped_ == MAP_FAILED) {
            throw std::runtime_error("Failed to map file");
        }
        
        header_ = static_cast<FileHeader*>(mapped_);
        
        // Verify layout
        if (header_->layout_hash != get_layout_hash<T>()) {
            munmap(mapped_, size_);
            throw std::runtime_error("Layout mismatch");
        }
        
        records_ = reinterpret_cast<T*>(
            static_cast<char*>(mapped_) + header_->data_offset);
    }
    
    ~MappedRecordFile() {
        if (mapped_ && mapped_ != MAP_FAILED) {
            munmap(mapped_, size_);
        }
    }
    
    std::uint64_t count() const { return header_->record_count; }
    
    const T& operator[](std::size_t index) const {
        return records_[index];
    }
    
    std::span<const T> all() const {
        return {records_, header_->record_count};
    }
};
----

== Integration with Boost.Serialization

[source,cpp]
----
#include <boost/archive/binary_oarchive.hpp>
#include <boost/archive/binary_iarchive.hpp>

// Add layout verification to Boost.Serialization
template<PortableType T>
class LayoutVerifiedArchive {
    std::ofstream file_;
    
public:
    explicit LayoutVerifiedArchive(const std::string& path)
        : file_(path, std::ios::binary)
    {
        // Write layout hash first
        auto hash = get_layout_hash<T>();
        file_.write(reinterpret_cast<const char*>(&hash), sizeof(hash));
    }
    
    void save(const T& obj) {
        boost::archive::binary_oarchive oa(file_);
        oa << obj;
    }
};

template<PortableType T>
class LayoutVerifiedInputArchive {
    std::ifstream file_;
    
public:
    explicit LayoutVerifiedInputArchive(const std::string& path)
        : file_(path, std::ios::binary)
    {
        std::uint64_t file_hash;
        file_.read(reinterpret_cast<char*>(&file_hash), sizeof(file_hash));
        
        if (file_hash != get_layout_hash<T>()) {
            throw std::runtime_error("Layout mismatch in archive");
        }
    }
    
    void load(T& obj) {
        boost::archive::binary_iarchive ia(file_);
        ia >> obj;
    }
};
----

== Best Practices

=== 1. Always Include Layout Hash

[source,cpp]
----
struct FileHeader {
    std::uint64_t layout_hash;  // Required for verification
    // ...
};
----

=== 2. Version Your Format

[source,cpp]
----
struct FileHeader {
    std::uint32_t version;      // For migration support
    std::uint64_t layout_hash;  // For verification
};
----

=== 3. Document Expected Hashes

[source,cpp]
----
// In your documentation:
// Record format v1: hash = 0x1234567890abcdef
// Record format v2: hash = 0xfedcba0987654321
----

=== 4. Test Backward Compatibility

[source,cpp]
----
TEST(Serialization, CanReadV1Files) {
    // Create v1 test file
    // Read with current version
    // Verify migration worked
}
----

== See Also

* xref:examples/network-protocol.adoc[Network Protocol Example]
* xref:examples/shared-memory.adoc[Shared Memory Example]
* xref:../user-guide/hash-verification.adoc[Hash Verification Guide]
