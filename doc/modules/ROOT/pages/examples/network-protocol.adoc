= Network Protocol Example
:navtitle: Network Protocol

Using Boost.TypeLayout for binary network protocol validation and versioning.

== Overview

This example demonstrates how to use TypeLayout to:

* Define portable protocol structures
* Verify layout compatibility between peers
* Detect protocol version mismatches at compile time

== Protocol Definition

=== Message Header

[source,cpp]
----
#include <boost/typelayout.hpp>
#include <cstdint>
#include <array>

using namespace boost::typelayout;

// Protocol constants
constexpr std::array<char, 4> PROTOCOL_MAGIC = {'M', 'Y', 'P', 'R'};
constexpr std::uint16_t PROTOCOL_VERSION = 1;

// Message header - must be portable
struct MessageHeader {
    std::array<char, 4> magic;       // Protocol identifier
    std::uint16_t version;           // Protocol version
    std::uint16_t message_type;      // Type of message
    std::uint32_t payload_length;    // Length of payload
    std::uint32_t sequence_number;   // Message sequence
};

// Verify header is portable at compile time
static_assert(is_portable<MessageHeader>(),
    "MessageHeader must be portable for network transmission");

// Store layout hash for version checking
constexpr auto HEADER_LAYOUT_HASH = get_layout_hash<MessageHeader>();
----

=== Message Types

[source,cpp]
----
// Authentication request
struct AuthRequest {
    std::array<char, 32> username;
    std::array<char, 64> password_hash;
    std::uint64_t timestamp;
};

static_assert(is_portable<AuthRequest>());
constexpr auto AUTH_REQUEST_HASH = get_layout_hash<AuthRequest>();

// Authentication response
struct AuthResponse {
    std::uint32_t status_code;
    std::uint64_t session_id;
    std::uint64_t expiry_timestamp;
};

static_assert(is_portable<AuthResponse>());
constexpr auto AUTH_RESPONSE_HASH = get_layout_hash<AuthResponse>();

// Data transfer message
struct DataMessage {
    std::uint64_t transaction_id;
    std::uint32_t chunk_index;
    std::uint32_t total_chunks;
    std::array<std::uint8_t, 1024> data;
};

static_assert(is_portable<DataMessage>());
constexpr auto DATA_MESSAGE_HASH = get_layout_hash<DataMessage>();
----

== Protocol Negotiation

=== Handshake Message

[source,cpp]
----
// Sent during connection establishment
struct Handshake {
    std::array<char, 4> magic;
    std::uint16_t protocol_version;
    std::uint8_t  pointer_size;      // 4 or 8
    std::uint8_t  endianness;        // 0=little, 1=big
    std::uint64_t header_layout_hash;
    std::uint64_t capabilities;      // Bitmask of supported features
};

static_assert(is_portable<Handshake>());

Handshake create_handshake() {
    return Handshake{
        .magic = PROTOCOL_MAGIC,
        .protocol_version = PROTOCOL_VERSION,
        .pointer_size = sizeof(void*),
        .endianness = (std::endian::native == std::endian::little) ? 0 : 1,
        .header_layout_hash = HEADER_LAYOUT_HASH,
        .capabilities = 0xFFFF  // All features supported
    };
}
----

=== Validation

[source,cpp]
----
#include <stdexcept>

enum class HandshakeResult {
    OK,
    MAGIC_MISMATCH,
    VERSION_MISMATCH,
    LAYOUT_MISMATCH,
    ENDIANNESS_MISMATCH
};

HandshakeResult validate_handshake(const Handshake& remote) {
    // Check magic bytes
    if (remote.magic != PROTOCOL_MAGIC) {
        return HandshakeResult::MAGIC_MISMATCH;
    }
    
    // Check protocol version
    if (remote.protocol_version != PROTOCOL_VERSION) {
        return HandshakeResult::VERSION_MISMATCH;
    }
    
    // Check layout compatibility
    if (remote.header_layout_hash != HEADER_LAYOUT_HASH) {
        return HandshakeResult::LAYOUT_MISMATCH;
    }
    
    // Check endianness (optional - could handle conversion)
    std::uint8_t local_endian = 
        (std::endian::native == std::endian::little) ? 0 : 1;
    if (remote.endianness != local_endian) {
        return HandshakeResult::ENDIANNESS_MISMATCH;
    }
    
    return HandshakeResult::OK;
}
----

== Complete Example

[source,cpp]
----
#include <boost/typelayout.hpp>
#include <iostream>
#include <cstring>
#include <vector>
#include <span>

using namespace boost::typelayout;

// Simulated network send/receive
class MockSocket {
    std::vector<std::byte> buffer_;
    
public:
    template<PortableType T>
    void send(const T& data) {
        auto bytes = std::as_bytes(std::span(&data, 1));
        buffer_.insert(buffer_.end(), bytes.begin(), bytes.end());
        std::cout << "Sent " << sizeof(T) << " bytes\n";
    }
    
    template<PortableType T>
    bool receive(T& data) {
        if (buffer_.size() < sizeof(T)) {
            return false;
        }
        std::memcpy(&data, buffer_.data(), sizeof(T));
        buffer_.erase(buffer_.begin(), buffer_.begin() + sizeof(T));
        std::cout << "Received " << sizeof(T) << " bytes\n";
        return true;
    }
    
    void clear() { buffer_.clear(); }
};

void run_protocol_example() {
    MockSocket socket;
    
    // === Client sends handshake ===
    std::cout << "=== Client Handshake ===\n";
    auto client_handshake = create_handshake();
    socket.send(client_handshake);
    
    // === Server receives and validates ===
    std::cout << "\n=== Server Validation ===\n";
    Handshake received_handshake;
    socket.receive(received_handshake);
    
    auto result = validate_handshake(received_handshake);
    switch (result) {
        case HandshakeResult::OK:
            std::cout << "Handshake successful!\n";
            break;
        case HandshakeResult::MAGIC_MISMATCH:
            std::cout << "Error: Protocol magic mismatch\n";
            return;
        case HandshakeResult::VERSION_MISMATCH:
            std::cout << "Error: Protocol version mismatch\n";
            return;
        case HandshakeResult::LAYOUT_MISMATCH:
            std::cout << "Error: Layout incompatibility detected\n";
            return;
        case HandshakeResult::ENDIANNESS_MISMATCH:
            std::cout << "Warning: Endianness mismatch\n";
            break;
    }
    
    // === Send authentication request ===
    std::cout << "\n=== Authentication ===\n";
    socket.clear();
    
    MessageHeader auth_header{
        .magic = PROTOCOL_MAGIC,
        .version = PROTOCOL_VERSION,
        .message_type = 1,  // AUTH_REQUEST
        .payload_length = sizeof(AuthRequest),
        .sequence_number = 1
    };
    socket.send(auth_header);
    
    AuthRequest auth{};
    std::memcpy(auth.username.data(), "alice", 5);
    socket.send(auth);
    
    std::cout << "\n=== Layout Information ===\n";
    std::cout << "MessageHeader: " << get_layout_signature<MessageHeader>() << "\n";
    std::cout << "AuthRequest:   " << get_layout_signature<AuthRequest>() << "\n";
}

int main() {
    std::cout << "Network Protocol Example\n";
    std::cout << "========================\n\n";
    
    run_protocol_example();
    
    return 0;
}
----

== Detecting Protocol Changes

=== Compile-Time Detection

When protocol structures change, compilation fails:

[source,cpp]
----
// protocol_v1.hpp - Original version
struct MessageHeader_v1 {
    std::uint32_t magic;
    std::uint16_t version;
    std::uint16_t type;
};

constexpr auto V1_HASH = get_layout_hash<MessageHeader_v1>();

// protocol_v2.hpp - Changed version
struct MessageHeader_v2 {
    std::uint32_t magic;
    std::uint16_t version;
    std::uint16_t type;
    std::uint32_t flags;  // Added field!
};

// This assertion catches the change at compile time
static_assert(get_layout_hash<MessageHeader_v2>() == V1_HASH,
    "BREAKING CHANGE: MessageHeader layout changed!");
// ^^ This fails - forces developer to update protocol version
----

=== Version Registry

[source,cpp]
----
#include <unordered_map>

// Registry of known layout hashes per version
struct ProtocolRegistry {
    static constexpr std::uint64_t V1_HEADER_HASH = 0x1234567890abcdef;
    static constexpr std::uint64_t V2_HEADER_HASH = 0xfedcba0987654321;
    
    static bool is_compatible(std::uint16_t version, std::uint64_t hash) {
        switch (version) {
            case 1: return hash == V1_HEADER_HASH;
            case 2: return hash == V2_HEADER_HASH;
            default: return false;
        }
    }
};
----

== Best Practices

=== 1. Always Use Fixed-Width Types

[source,cpp]
----
// ‚ú?Good
struct GoodMessage {
    std::uint32_t id;
    std::int64_t value;
};

// ‚ù?Bad
struct BadMessage {
    int id;        // Size varies
    long value;    // Size varies
};
----

=== 2. Include Layout Hash in Protocol

[source,cpp]
----
struct ProtocolHeader {
    std::uint64_t layout_hash;  // Always first
    // ... other fields
};
----

=== 3. Version Your Protocol

[source,cpp]
----
constexpr std::uint16_t CURRENT_VERSION = 2;

// Document expected hashes per version
// Version 1: MessageHeader hash = 0x...
// Version 2: MessageHeader hash = 0x... (added flags field)
----

=== 4. Test Layout Stability

[source,cpp]
----
// In your test suite
TEST(Protocol, LayoutStability) {
    // These hashes should never change for released versions
    EXPECT_EQ(get_layout_hash<MessageHeader>(), 0x1234567890abcdef);
    EXPECT_EQ(get_layout_hash<AuthRequest>(), 0xabcdef1234567890);
}
----

== See Also

* xref:examples/shared-memory.adoc[Shared Memory Example]
* xref:examples/serialization.adoc[Serialization Example]
* xref:../user-guide/portability.adoc[Portability Guide]
