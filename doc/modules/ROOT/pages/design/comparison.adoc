= Competitive Analysis
:navtitle: Comparison
:description: Comparison of Boost.TypeLayout with alternative solutions

== Executive Summary

Boost.TypeLayout occupies a unique position in the C++ ecosystem. It is *not* a serialization frameworkâ€”it is a *layout verification engine* that validates whether native C++ types can be safely used for binary data exchange.

[cols="1,2,2"]
|===
| Layer | What TypeLayout Does | Competition Status

| *Core* (Layout Signature)
| Generates compile-time layout signatures via P2996 reflection
| ğŸŸ¢ *No direct competitors* â€” first practical P2996 application

| *Utility* (Serialization Check)
| Validates if types are safe for memcpy serialization
| ğŸŸ¡ Partial overlap with type traits, but more comprehensive

| *Application* (Serialization)
| Enables zero-copy binary transmission
| ğŸ”´ *Not competing* â€” complementary to serialization frameworks
|===

== Problem Domain: Binary Data Exchange

[source]
----
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Binary Data Exchange                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Layer 3: Application Scenarios                                 â”‚
â”‚  â”œâ”€â”€ Network Protocols    â† Protobuf, FlatBuffers, Cap'n Proto  â”‚
â”‚  â”œâ”€â”€ Persistent Storage   â† Boost.Serialization, cereal         â”‚
â”‚  â””â”€â”€ Shared Memory/IPC    â† Usually manual or no verification   â”‚
â”‚                                                                 â”‚
â”‚  Layer 2: Serialization Safety    â† TypeLayout.Util             â”‚
â”‚  â””â”€â”€ "Can this type be safely memcpy'd?"                        â”‚
â”‚                                                                 â”‚
â”‚  Layer 1: Layout Signature        â† TypeLayout.Core             â”‚
â”‚  â””â”€â”€ "What is this type's memory layout?"  â† [NOVEL]            â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
----

== Layer 1: Layout Signature Generation â€” No Direct Competitors

=== What TypeLayout.Core Does

[source,cpp]
----
// Input: Any C++ type
struct Point { int32_t x, y; };

// Output: Human-readable compile-time signature string
// "[64-le]struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}"
constexpr auto sig = get_layout_signature<Point>();
----

=== Why No Direct Competitors?

[cols="1,1,2"]
|===
| Existing Approach | Partial Solution? | Gap

| `offsetof()` macro
| Partial
| Only single field offset, no complete signature

| `sizeof()` + `alignof()`
| Partial
| Only size/alignment, no field information

| `boost::pfr` / `magic_get`
| Partial
| Can reflect fields, but no offsets, no signature generation

| Compiler debug info
| No
| Not compile-time constant, cannot be used in `static_assert`

| *P2996 Reflection*
| Infrastructure
| This is the underlying technology TypeLayout uses, not a competitor
|===

*Conclusion*: TypeLayout.Core is the *first practical implementation of P2996 reflection for layout verification*. There are currently no direct competitors.

== Layer 2: Serialization Safety Check â€” Competitors with Different Focus

=== What TypeLayout.Util Does

[source,cpp]
----
// Check: Can this type be safely memcpy-serialized?
static_assert(Serializable<Point>);  // Passes
static_assert(Serializable<struct { int* p; }>);  // Fails: contains pointer
----

=== Alternative Approaches

[cols="1,2,2"]
|===
| Approach | How It Works | Relationship to TypeLayout

| `std::is_trivially_copyable`
| Standard type trait
| Only one part of TypeLayout's checks

| Manual `static_assert`
| Per-field checking
| Tedious, error-prone, not composable

| Code review
| Human inspection
| Unreliable, not automatable
|===

*TypeLayout.Util Advantage*: Recursively checks all nested members, including bit-fields, platform-dependent types (`long`), inheritance, and more.

== Layer 3: Serialization Frameworks â€” Complementary, Not Competing

This is the layer with many mature solutions:

=== Comparison Table

[cols="1,2,1,1,1"]
|===
| Framework | Approach | Zero-Copy? | Needs IDL? | Compile-Time Verification?

| *Boost.TypeLayout*
| Validates native structs
| âœ… Yes
| âŒ No
| âœ… Yes

| Protocol Buffers
| Generates serialization code
| âŒ No
| âœ… Yes
| Partial

| FlatBuffers
| Generates accessors
| âœ… Yes
| âœ… Yes
| Partial

| Cap'n Proto
| Generates accessors
| âœ… Yes
| âœ… Yes
| Partial

| Boost.Serialization
| Manual/intrusive
| âŒ No
| âŒ No
| âŒ No

| cereal
| Intrusive macros
| âŒ No
| âŒ No
| âŒ No
|===

=== Key Philosophical Difference

[source]
----
TypeLayout's Position:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ "Your native C++ struct IS the protocol"                   â”‚
â”‚                                                            â”‚
â”‚ â€¢ No IDL files needed                                      â”‚
â”‚ â€¢ No code generation step                                  â”‚
â”‚ â€¢ No changes to your struct definitions                    â”‚
â”‚ â€¢ Direct memcpy, zero overhead                             â”‚
â”‚ â€¢ Compile-time verification of expected layout             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Serialization Frameworks' Position:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ "We define a new data representation format"               â”‚
â”‚                                                            â”‚
â”‚ â€¢ Learn IDL syntax (proto, fbs, capnp)                     â”‚
â”‚ â€¢ Code generation step required                            â”‚
â”‚ â€¢ Generated code may differ from your business types       â”‚
â”‚ â€¢ Serialization/deserialization overhead (even FlatBuffers)â”‚
â”‚ â€¢ Provides versioning, cross-language support, etc.        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
----

== Use Case Comparison

=== Scenario 1: High-Performance Game Server

[source,cpp]
----
// TypeLayout approach: Use native structs directly
struct PlayerState {
    uint64_t player_id;
    float position[3];
    uint32_t health;
};
static_assert(Serializable<PlayerState>);
// Direct memcpy to network buffer, zero overhead

// Protobuf approach:
// 1. Write .proto file
// 2. Generate PlayerState.pb.h
// 3. Use SerializeToArray() / ParseFromArray()
// 4. Encoding/decoding overhead exists
----

=== Scenario 2: Shared Memory IPC

[source,cpp]
----
// TypeLayout approach:
template<SharedMemorySafe T>
T* map_shm(const char* name);

auto* data = map_shm<MyData>("my_shm");
// Compile-time guarantee that MyData is safe for cross-process sharing

// Traditional approach:
// Hope both sides have the same layout
// Or manually #pragma pack(1) and hope for the best
----

=== Scenario 3: Binary Protocol Version Control

[source,cpp]
----
// TypeLayout approach:
struct PacketV1 { uint32_t cmd; uint64_t payload; };
TYPELAYOUT_BIND(PacketV1, "[64-le]struct[s:16,a:8]{...}");
// If anyone modifies PacketV1, compilation fails immediately

// Traditional approach:
// Protocol documentation + code review + hope nobody makes mistakes
----

== Detailed Framework Comparison

=== Protocol Buffers

*Strengths*:

* Cross-language support (C++, Java, Python, Go, etc.)
* Schema evolution with forward/backward compatibility
* Self-describing wire format
* Mature ecosystem with extensive tooling

*When to choose over TypeLayout*:

* Need cross-language interoperability
* Need schema evolution over time
* External API communication

*When TypeLayout is better*:

* Pure C++ environment
* Maximum performance required
* Existing struct definitions
* No code generation in build process

=== FlatBuffers

*Strengths*:

* Zero-copy access to serialized data
* Memory-efficient (no parsing step)
* Cross-language support
* Good for games and performance-critical applications

*When to choose over TypeLayout*:

* Need cross-language support
* Need optional fields
* Complex nested structures with random access

*When TypeLayout is better*:

* Simple POD structures
* True zero-overhead (FlatBuffers still has accessor overhead)
* No IDL in workflow

=== Cap'n Proto

*Strengths*:

* Zero-copy with memory-mapped files
* RPC system built-in
* Time-travel debugging support

*When to choose over TypeLayout*:

* Need RPC framework
* Need cross-language support
* Complex distributed systems

*When TypeLayout is better*:

* Simpler use cases
* No external dependencies
* Header-only solution

=== boost::pfr / magic_get

*Strengths*:

* Works with C++17/20 (no P2996 required)
* Field iteration for aggregates
* No macros needed

*Limitations vs TypeLayout*:

* Cannot get field offsets
* Cannot generate complete layout signature
* Cannot verify bit-field layout
* No serialization safety checking

[source,cpp]
----
// boost::pfr can do this:
boost::pfr::for_each_field(point, [](auto& field) { ... });

// TypeLayout can do this (pfr cannot):
constexpr auto sig = get_layout_signature<Point>();
constexpr auto offset = get_field_offset<Point, 0>();
static_assert(Serializable<Point>);
----

== Relationship Summary

TypeLayout and serialization frameworks are *not competitors* â€” they represent *different choices*:

[cols="1,2"]
|===
| Choose TypeLayout when... | Choose Serialization Frameworks when...

| Your struct is already well-designed
| You need cross-language support

| You want to verify it's safe for transmission
| You need schema evolution

| Maximum performance is critical
| You need self-describing formats

| No code generation in build process
| External API communication

| Pure C++ environment
| Complex distributed systems
|===

*They can coexist*: A project can use TypeLayout (for internal high-performance paths) alongside Protobuf (for external API interactions).

== Conclusion

Boost.TypeLayout's unique value proposition:

[source]
----
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                             â”‚
â”‚   TypeLayout is NOT "another serialization framework"       â”‚
â”‚                                                             â”‚
â”‚   TypeLayout is "a safety validator for native struct       â”‚
â”‚   serialization"                                            â”‚
â”‚                                                             â”‚
â”‚   The question it answers:                                  â”‚
â”‚   "Can I memcpy this struct directly? Is it safe?           â”‚
â”‚    Cross-platform?"                                         â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
----

[cols="1,2"]
|===
| Layer | Competition Status

| *Core (Layout Signature)*
| ğŸŸ¢ No direct competitors â€” first P2996 application

| *Utility (Serialization Check)*
| ğŸŸ¡ Similar concepts exist, but TypeLayout is more comprehensive

| *Application (Serialization)*
| ğŸ”´ Not competing â€” complementary relationship
|===
