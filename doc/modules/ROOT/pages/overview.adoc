= Overview
:navtitle: Overview

== The Problem: Silent Binary Incompatibility

Binary compatibility bugs are among the most insidious in systems programming. Two programs exchange raw bytes through shared memory or network protocols‚Äîboth compile successfully, both pass unit tests, yet one reads garbage from the other.

The culprit: *invisible differences in struct layout* caused by:

* Compiler variations
* Platform differences  
* Innocent refactoring

=== A Real-World Example

[source,cpp]
----
// The problem: same struct, different layout on Windows vs Linux
struct Record {
    int32_t id;
    long    timestamp;  // 4 bytes on Windows (LLP64), 8 bytes on Linux (LP64)!
    int32_t flags;
};
// Windows: sizeof = 12, offsets: id@0, timestamp@4, flags@8
// Linux:   sizeof = 24, offsets: id@0, timestamp@8, flags@16
// Cross-platform shared memory = silent data corruption!
----

=== Why Traditional Solutions Fail

[cols="1,2"]
|===
| Approach | Problem

| `static_assert(sizeof(...))` 
| Only checks size, not internal layout

| `#pragma pack`
| Non-portable and error-prone

| Runtime checks
| Catch bugs too late‚Äîafter deployment
|===

== The Solution: Compile-Time Layout Contracts

Boost.TypeLayout leverages {cpp26} Static Reflection (P2996) to generate *complete, semantic layout signatures* at compile time.

[source,cpp]
----
// Works with struct
struct Player { uint64_t id; char name[32]; float health; };
TYPELAYOUT_BIND(Player, "[64-le]struct[s:48,a:8]{@0[id]:u64[s:8,a:8],@8[name]:bytes[s:32,a:1],@40[health]:f32[s:4,a:4]}");

// Works equally well with class (including private members)
class GameEntity {
public:
    GameEntity(uint64_t id) : id_(id), active_(true) {}
private:
    uint64_t id_;     // Private - still reflected!
    bool active_;     // Private - still reflected!
};
TYPELAYOUT_BIND(GameEntity, "[64-le]struct[s:16,a:8]{@0[id_]:u64[s:8,a:8],@8[active_]:bool[s:1,a:1]}");
----

If the layout ever differs‚Äîon any platform, with any compiler‚Ä?compilation fails immediately*.

NOTE: TypeLayout is *NOT* limited to `struct` or POD types. It fully supports classes with private members, inheritance, virtual functions, and complex constructors.

== The Core Guarantee

[IMPORTANT]
====
**Same Signature ‚ü?Same Memory Layout**

This is not an approximation‚Äîit is mathematically sound. The signature captures `sizeof`, `alignof`, member offsets, types, and platform information. If ANY of these differ, the signature differs.
====

== Safe Data Sharing Across Three Boundaries

The core guarantee enables safe data sharing across three critical boundaries:

=== üîÑ Cross-Process (Shared Memory / IPC)

When multiple processes access the same memory region, layout mismatches cause silent corruption. TypeLayout prevents this at compile time.

[source,cpp]
----
// Process A: Writer
#include <boost/typelayout.hpp>

struct SharedData { int32_t id; float value; };
TYPELAYOUT_BIND(SharedData, "[64-le]struct[s:8,a:4]{@0[id]:i32[s:4,a:4],@4[value]:f32[s:4,a:4]}");

void* shm = create_shared_memory("my_shm", sizeof(SharedData));
new (shm) SharedData{42, 3.14f};
----

[source,cpp]
----
// Process B: Reader (compiled separately)
struct SharedData { int32_t id; float value; };
TYPELAYOUT_BIND(SharedData, "[64-le]struct[s:8,a:4]{@0[id]:i32[s:4,a:4],@4[value]:f32[s:4,a:4]}");
// ‚ú?Compilation succeeds = layouts match = safe to read

auto* data = static_cast<SharedData*>(open_shared_memory("my_shm"));
assert(data->id == 42);  // Guaranteed correct
----

=== üåê Cross-Machine (Network / Files)

Binary data transmitted between machines with different architectures requires layout verification.

[source,cpp]
----
// Server (x86_64 Linux)
#include <boost/typelayout.hpp>

struct NetworkHeader {
    uint32_t magic;
    uint32_t version;
    uint64_t timestamp;
};
constexpr uint64_t PROTOCOL_HASH = get_layout_hash<NetworkHeader>();

void send_header(int socket, const NetworkHeader& hdr) {
    // Include hash in protocol for runtime verification
    send(socket, &PROTOCOL_HASH, sizeof(PROTOCOL_HASH), 0);
    send(socket, &hdr, sizeof(NetworkHeader), 0);
}
----

[source,cpp]
----
// Client (ARM64 macOS) - compile-time contract
TYPELAYOUT_BIND(NetworkHeader, 
    "[64-le]struct[s:16,a:8]{@0[magic]:u32[s:4,a:4],@4[version]:u32[s:4,a:4],@8[timestamp]:u64[s:8,a:8]}");
// ‚ù?If ARM client has different layout, compilation fails immediately
----

=== ‚è?Cross-Time (Binary Compatibility / Versioning)

Saved binary data must remain readable across software versions.

[source,cpp]
----
// Version 1.0 (2024) - define the contract
struct SaveGame {
    uint32_t version;
    int32_t player_hp;
    int32_t player_gold;
};
// Save the signature as the "Version 1.0 contract"
constexpr auto V1_SIGNATURE = 
    "[64-le]struct[s:12,a:4]{@0[version]:u32[s:4,a:4],@4[player_hp]:i32[s:4,a:4],@8[player_gold]:i32[s:4,a:4]}";
----

[source,cpp]
----
// Version 2.0 (2026) - must honor old saves
struct SaveGame {
    uint32_t version;
    int32_t player_hp;
    int32_t player_gold;
    // New fields can be added, but V1 compatibility check uses V1_SIGNATURE
};

// Load function validates against V1 contract
template<typename T>
void load_v1_save(const char* path) {
    static_assert(get_layout_signature<T>().starts_with("[64-le]struct[s:12"),
        "Breaking change to V1 save format!");
    // ... load logic
}
====

== Two-Layer Architecture

Boost.TypeLayout is organized into two distinct layers:

=== Layer 1: Core ‚Ä?Layout Signature Engine

**Header**: `<boost/typelayout.hpp>`

The foundation of the library. Provides pure memory layout analysis:

* **Signature Generation**: `get_layout_signature<T>()` produces bit-accurate layout descriptions
* **Hash Functions**: `get_layout_hash<T>()`, `get_layout_verification<T>()` for efficient comparison
* **Comparison**: `signatures_match<T, U>()` verifies layout identity between types
* **Concepts**: `LayoutCompatible`, `LayoutMatch`, `LayoutHashMatch`

=== Layer 2: Utility ‚Ä?Serialization Safety Analysis

**Header**: `<boost/typelayout/typelayout_util.hpp>`

Built on top of the core layer, provides practical serialization utilities:

* **Platform Sets**: `PlatformSet` defines target architectures
* **Serialization Checking**: `is_serializable_v<T, P>` validates serialization safety
* **Concepts**: `Serializable`, `ZeroCopyTransmittable`

=== Why Two Layers?

[cols="1,2"]
|===
| Benefit | Description

| Focused usage
| Use core for ABI verification without serialization overhead

| Clean dependencies
| Core has no policy dependencies; utility builds on core

| Extensibility
| Extend utility layer with custom serialization policies
|===

== How It Works

=== 1. Reflection-Based Introspection

The library uses P2996 reflection APIs to inspect types at compile time:

[source,cpp]
----
template<typename T>
consteval auto get_first_field_name() {
    constexpr auto members = std::meta::nonstatic_data_members_of(^^T);
    return std::meta::identifier_of(members[0]);
}
----

=== 2. Signature Generation

Signatures capture complete layout information:

* Field names and types
* Byte offsets
* Size and alignment
* Platform information (architecture, endianness)

=== 3. Compile-Time Verification

Using `static_assert` and concepts, layout contracts are enforced at compile time with zero runtime cost.

== Key Concepts

=== Layout Signature

A human-readable string that uniquely identifies a type's memory layout:

----
[64-le]struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}
----

Components:

* `[64-le]` - Platform prefix (64-bit, little-endian)
* `struct[s:8,a:4]` - Type category, size 8 bytes, alignment 4
* `@0[x]` - Field at offset 0, named "x"
* `:i32[s:4,a:4]` - Type signature with size/alignment

=== Serializability

A type is *serializable* if it is safe for binary persistence/transmission across platforms. Non-serializable types include:

* `wchar_t` - 2 bytes (Windows) vs 4 bytes (Linux)
* `long` - 4 bytes (Windows LLP64) vs 8 bytes (Linux LP64)
* `long double` - 8/12/16 bytes depending on platform
* Bit-fields - Bit packing order is implementation-defined
* Pointers - Not meaningful outside the current process

=== Hash Verification

For runtime validation (e.g., protocol headers), the library provides:

* 64-bit FNV-1a hash
* Dual-hash verification (FNV-1a + DJB2) with ~2^128 collision resistance

== Next Steps

* xref:quickstart.adoc[Quick Start] - Get started in 5 minutes
* xref:user-guide/layout-signatures.adoc[Layout Signatures] - Deep dive into signatures
* xref:reference/index.adoc[API Reference] - Complete API documentation
