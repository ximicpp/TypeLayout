= Macros
:navtitle: Macros

Reference documentation for the macros provided by Boost.TypeLayout.

[#TYPELAYOUT_BIND]
== TYPELAYOUT_BIND

Binds a type to an expected layout signature with compile-time verification.

=== Synopsis

[source,cpp]
----
#define TYPELAYOUT_BIND(Type, Signature)
----

=== Parameters

`Type`::
The type to bind. Must be a complete type name (not a type expression).

`Signature`::
A string literal containing the expected layout signature.

=== Description

This macro creates a compile-time assertion that the type's layout signature matches the expected signature. If there is a mismatch, compilation fails with an error message.

=== Implementation

The macro expands to approximately:

[source,cpp]
----
static_assert(
    boost::typelayout::get_layout_signature<Type>() == Signature,
    "Layout mismatch for type: " #Type
);
----

=== Example

[source,cpp]
----
#include <boost/typelayout.hpp>

struct Point {
    int x;
    int y;
};

// Bind Point to its expected signature
TYPELAYOUT_BIND(Point, 
    "[64-le]struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}");

struct NetworkPacket {
    std::uint32_t type;
    std::uint32_t length;
    std::uint64_t timestamp;
};

TYPELAYOUT_BIND(NetworkPacket,
    "[64-le]struct[s:16,a:8]{@0[type]:u32[s:4,a:4],@4[length]:u32[s:4,a:4],@8[timestamp]:u64[s:8,a:8]}");
----

=== Error Messages

When the layout doesn't match, you'll get a compile-time error:

[source]
----
error: static assertion failed: Layout mismatch for type: Point
note: 'boost::typelayout::get_layout_signature<Point>()' evaluates to
      "[64-le]struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}"
note: expected
      "[64-le]struct[s:8,a:4]{@0[a]:i32[s:4,a:4],@4[b]:i32[s:4,a:4]}"
----

=== Use Cases

==== Cross-Platform Verification

[source,cpp]
----
// Ensure consistent layout across platforms
struct Message {
    std::int32_t id;
    std::int32_t type;
    std::int64_t timestamp;
};

// This will fail compilation if layout differs on any platform
TYPELAYOUT_BIND(Message,
    "[64-le]struct[s:16,a:8]{@0[id]:i32[s:4,a:4],@4[type]:i32[s:4,a:4],@8[timestamp]:i64[s:8,a:8]}");
----

==== Preventing Accidental Changes

[source,cpp]
----
// Struct used in file format - layout must not change
struct FileRecord {
    std::uint32_t flags;
    std::uint32_t size;
    std::uint64_t offset;
    char name[256];
};

TYPELAYOUT_BIND(FileRecord,
    "[64-le]struct[s:272,a:8]{@0[flags]:u32[s:4,a:4],@4[size]:u32[s:4,a:4],@8[offset]:u64[s:8,a:8],@16[name]:array<256>[s:256,a:1]{char[s:1,a:1]}}");

// If anyone modifies FileRecord, they must update the signature
----

==== Protocol Buffers / Wire Formats

[source,cpp]
----
// Wire format for network protocol v2
struct ProtocolV2Header {
    std::uint16_t magic;
    std::uint16_t version;
    std::uint32_t length;
    std::uint64_t sequence;
};

// Document and verify the expected wire format
TYPELAYOUT_BIND(ProtocolV2Header,
    "[64-le]struct[s:16,a:8]{@0[magic]:u16[s:2,a:2],@2[version]:u16[s:2,a:2],@4[length]:u32[s:4,a:4],@8[sequence]:u64[s:8,a:8]}");
----

=== Best Practices

1. **Place near type definition**
+
Keep the `TYPELAYOUT_BIND` close to the type definition so changes to the type remind developers to update the signature.

2. **Use for external interfaces**
+
Apply to types used in:
- File formats
- Network protocols
- Shared memory
- Plugin interfaces

3. **Generate signature first**
+
Use `get_layout_signature<T>()` to generate the correct signature, then paste it into `TYPELAYOUT_BIND`.

4. **Consider platform differences**
+
Remember that signatures include platform info (`[64-le]`). You may need conditional compilation for cross-platform code:
+
[source,cpp]
----
#if defined(_WIN64)
TYPELAYOUT_BIND(MyType, "[64-le]struct[s:16,a:8]{...}");
#elif defined(__linux__) && defined(__x86_64__)
TYPELAYOUT_BIND(MyType, "[64-le]struct[s:16,a:8]{...}");
#endif
----

=== Template Types

`TYPELAYOUT_BIND` works with template instantiations:

[source,cpp]
----
template<typename T>
struct Container {
    T value;
    std::size_t size;
};

// Bind specific instantiations
TYPELAYOUT_BIND(Container<int>,
    "[64-le]struct[s:16,a:8]{@0[value]:i32[s:4,a:4],@8[size]:u64[s:8,a:8]}");

TYPELAYOUT_BIND(Container<double>,
    "[64-le]struct[s:16,a:8]{@0[value]:f64[s:8,a:8],@8[size]:u64[s:8,a:8]}");
----

=== Limitations

* Cannot be used inside function bodies (must be at namespace or class scope)
* Type must be complete at the point of use
* Signature string must be a literal (not a variable)

=== See Also

* xref:core-functions.adoc#get_layout_signature[get_layout_signature] - Generate signatures
* xref:../user-guide/layout-signatures.adoc[Layout Signatures] - Signature format
