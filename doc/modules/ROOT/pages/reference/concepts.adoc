= Concepts
:navtitle: Concepts

Reference documentation for the concepts provided by Boost.TypeLayout.

[#Portable]
== Portable

Constrains a type to be free from platform-dependent members.

=== Synopsis

[source,cpp]
----
namespace boost::typelayout {

template<typename T>
concept Portable = is_portable<T>();

}
----

=== Semantic Requirements

A type `T` satisfies `Portable` if and only if `is_portable<T>()` returns `true`.

=== Example

[source,cpp]
----
#include <boost/typelayout.hpp>

template<boost::typelayout::Portable T>
void write_to_network(const T& data);

struct PortableData {
    std::int32_t x;
    std::int32_t y;
};

struct NonPortableData {
    long x;  // Platform-dependent
    long y;
};

PortableData pd;
write_to_network(pd);  // OK

NonPortableData npd;
// write_to_network(npd);  // Error: constraint not satisfied
----

=== See Also

* xref:reference/core-functions.adoc#is_portable[is_portable] - Underlying function

'''

[#LayoutCompatible]
== LayoutCompatible

Constrains two types to have identical memory layouts.

=== Synopsis

[source,cpp]
----
namespace boost::typelayout {

template<typename T, typename U>
concept LayoutCompatible = signatures_match<T, U>();

}
----

=== Semantic Requirements

Types `T` and `U` satisfy `LayoutCompatible` if and only if `signatures_match<T, U>()` returns `true`.

=== Example

[source,cpp]
----
#include <boost/typelayout.hpp>

template<typename Target, typename Source>
    requires boost::typelayout::LayoutCompatible<Target, Source>
Target& reinterpret_as(Source& src) {
    return *reinterpret_cast<Target*>(&src);
}

struct A { int x; int y; };
struct B { int x; int y; };  // Same layout as A (same names)
struct C { int a; int b; };  // Different member names

A a{1, 2};
B& b_ref = reinterpret_as<B>(a);  // OK: same layout
// C& c_ref = reinterpret_as<C>(a);  // Error: different member names
----

=== Notes

Layout compatibility requires:

* Same total size
* Same alignment
* Same member types in same order
* Same member names (signatures include names)

=== See Also

* xref:reference/core-functions.adoc#signatures_match[signatures_match] - Underlying function

'''

[#LayoutMatch]
== LayoutMatch

Constrains a type's layout to match a specific signature string.

=== Synopsis

[source,cpp]
----
namespace boost::typelayout {

template<typename T, CompileString Sig>
concept LayoutMatch = get_layout_signature<T>() == Sig;

}
----

=== Semantic Requirements

A type `T` satisfies `LayoutMatch<T, Sig>` if and only if `get_layout_signature<T>()` equals the compile-time string `Sig`.

=== Example

[source,cpp]
----
#include <boost/typelayout.hpp>

constexpr auto POINT_SIG = 
    "[64-le]struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}"_cs;

template<typename T>
    requires boost::typelayout::LayoutMatch<T, POINT_SIG>
void process_point(const T& point) {
    // Type is guaranteed to have Point layout
}

struct Point { int x; int y; };
struct NotPoint { float x; float y; };

Point p;
process_point(p);  // OK

NotPoint np;
// process_point(np);  // Error: layout doesn't match
----

=== Notes

* The signature must be a compile-time string (`CompileString<N>`)
* Use the `_cs` literal suffix to create compile-time strings
* Signature comparison is exact (includes platform info)

=== See Also

* xref:reference/core-functions.adoc#get_layout_signature[get_layout_signature] - Underlying function
* xref:reference/utility-classes.adoc#CompileString[CompileString] - Compile-time string type

'''

[#LayoutHashMatch]
== LayoutHashMatch

Constrains a type's layout hash to match a specific value.

=== Synopsis

[source,cpp]
----
namespace boost::typelayout {

template<typename T, std::uint64_t Hash>
concept LayoutHashMatch = get_layout_hash<T>() == Hash;

}
----

=== Semantic Requirements

A type `T` satisfies `LayoutHashMatch<T, Hash>` if and only if `get_layout_hash<T>()` equals `Hash`.

=== Example

[source,cpp]
----
#include <boost/typelayout.hpp>

// Known hash value from reference implementation
constexpr std::uint64_t PROTOCOL_V1_HASH = 0x1234567890ABCDEF;

template<typename T>
    requires boost::typelayout::LayoutHashMatch<T, PROTOCOL_V1_HASH>
void send_protocol_v1(const T& message) {
    // Type is guaranteed to have correct layout for protocol v1
}

struct Message {
    std::uint32_t type;
    std::uint32_t length;
    std::uint64_t timestamp;
};

// Verify at compile time
static_assert(boost::typelayout::LayoutHashMatch<Message, PROTOCOL_V1_HASH>);
----

=== Notes

* Hash-based checking is more compact than full signature comparison
* Use for protocol versioning or file format verification
* Consider dual-hash verification for safety-critical applications

=== See Also

* xref:reference/core-functions.adoc#get_layout_hash[get_layout_hash] - Underlying function
* xref:reference/core-functions.adoc#get_layout_verification[get_layout_verification] - Dual-hash alternative
