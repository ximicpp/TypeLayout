= Platform Support
:navtitle: Platform Support

Platform-specific considerations and cross-platform compatibility for Boost.TypeLayout.

== Supported Platforms

=== Operating Systems

|===
| Platform | Status | Notes

| Linux (x86_64)
| ‚ú?Fully supported
| Primary development platform

| Linux (ARM64)
| ‚ú?Supported
| Different pointer size/endianness

| macOS (x86_64)
| ‚ú?Supported
| Requires Clang P2996 branch

| macOS (ARM64)
| ‚ú?Supported
| Apple Silicon, little-endian

| Windows (x86_64)
| ‚è?Pending
| Waiting for MSVC P2996 support

| FreeBSD
| ‚ö†Ô∏è Untested
| Should work with Clang

|===

=== Architecture Considerations

[cols="1,1,1,1"]
|===
| Architecture | Pointer Size | Default Endianness | Notes

| x86_64
| 8 bytes
| Little-endian
| Most common

| ARM64
| 8 bytes
| Little-endian (usually)
| Some big-endian variants

| x86 (32-bit)
| 4 bytes
| Little-endian
| Legacy support

| PowerPC
| 4/8 bytes
| Big-endian
| Limited testing
|===

== Platform Detection

Boost.TypeLayout automatically detects platform characteristics:

=== Pointer Size Detection

[source,cpp]
----
// Signature prefix includes pointer size
// [64-le] for 64-bit little-endian
// [32-be] for 32-bit big-endian

constexpr auto sig = get_layout_signature<MyType>();
// sig starts with platform indicator
----

=== Endianness Detection

[source,cpp]
----
constexpr bool is_little_endian = 
    (std::endian::native == std::endian::little);

// Included in signature: "le" or "be"
----

== Cross-Platform Compatibility

=== Portable Types

These types have consistent layout across platforms:

[source,cpp]
----
// Fixed-width integers - PORTABLE
struct PortableData {
    std::int8_t   a;    // Always 1 byte
    std::int16_t  b;    // Always 2 bytes
    std::int32_t  c;    // Always 4 bytes
    std::int64_t  d;    // Always 8 bytes
    std::uint8_t  e;    // Always 1 byte (unsigned)
    float         f;    // IEEE 754 single (4 bytes)
    double        g;    // IEEE 754 double (8 bytes)
    char          h;    // Always 1 byte
    bool          i;    // 1 byte (usually)
};
----

=== Non-Portable Types

These types vary across platforms:

[source,cpp]
----
// Platform-dependent types - NOT PORTABLE
struct NonPortableData {
    int           a;    // 4 bytes (usually), but not guaranteed
    long          b;    // 4 bytes (Windows) or 8 bytes (Linux)
    long long     c;    // 8 bytes (usually)
    size_t        d;    // 4 or 8 bytes
    ptrdiff_t     e;    // 4 or 8 bytes
    wchar_t       f;    // 2 bytes (Windows) or 4 bytes (Linux)
    long double   g;    // 8, 12, or 16 bytes
    void*         h;    // 4 or 8 bytes
};
----

=== Checking Portability

[source,cpp]
----
#include <boost/typelayout.hpp>

struct NetworkPacket {
    std::uint32_t sequence;
    std::uint16_t length;
    std::uint8_t  flags;
};

// Verify type is cross-platform safe
static_assert(is_portable<NetworkPacket>(), 
    "NetworkPacket must be portable for network transmission");
----

== Platform-Specific Behavior

=== Windows (x86_64)

[source,cpp]
----
// Windows LLP64 model
sizeof(int)       == 4   // ‚ú?
sizeof(long)      == 4   // ‚ú?(different from Linux!)
sizeof(long long) == 8   // ‚ú?
sizeof(size_t)    == 8   // ‚ú?
sizeof(wchar_t)   == 2   // ‚ú?(UTF-16)
----

=== Linux (x86_64)

[source,cpp]
----
// Linux LP64 model
sizeof(int)       == 4   // ‚ú?
sizeof(long)      == 8   // ‚ú?(different from Windows!)
sizeof(long long) == 8   // ‚ú?
sizeof(size_t)    == 8   // ‚ú?
sizeof(wchar_t)   == 4   // ‚ú?(UTF-32)
----

=== macOS (ARM64)

[source,cpp]
----
// macOS LP64 model (same as Linux)
sizeof(int)       == 4   // ‚ú?
sizeof(long)      == 8   // ‚ú?
sizeof(long long) == 8   // ‚ú?
sizeof(size_t)    == 8   // ‚ú?
sizeof(wchar_t)   == 4   // ‚ú?
----

== Alignment Considerations

=== Natural Alignment

Most platforms use natural alignment:

[source,cpp]
----
struct Aligned {
    char   a;      // offset 0, size 1
    // 3 bytes padding
    int    b;      // offset 4, size 4
    double c;      // offset 8, size 8
};
// sizeof(Aligned) == 16, alignof(Aligned) == 8
----

=== Packed Structures

Packed structures may have platform-specific behavior:

[source,cpp]
----
#pragma pack(push, 1)
struct Packed {
    char   a;      // offset 0
    int    b;      // offset 1 (unaligned!)
    double c;      // offset 5 (unaligned!)
};
#pragma pack(pop)
// sizeof(Packed) == 13

// WARNING: Unaligned access may be slow or cause faults
// on some architectures (ARM, SPARC)
----

== Cross-Platform Development Guidelines

=== 1. Use Fixed-Width Types

[source,cpp]
----
// ‚ú?Good - portable
struct Message {
    std::uint32_t id;
    std::int64_t  timestamp;
};

// ‚ù?Bad - platform-dependent
struct Message {
    unsigned int id;
    long timestamp;
};
----

=== 2. Verify Portability at Compile Time

[source,cpp]
----
template<typename T>
void send_over_network(const T& data) {
    static_assert(is_portable<T>(),
        "Only portable types can be sent over network");
    // ...
}
----

=== 3. Include Platform Info in Protocols

[source,cpp]
----
struct ProtocolHeader {
    std::uint8_t  magic[4];      // "MYPR"
    std::uint8_t  version;       // Protocol version
    std::uint8_t  ptr_size;      // 4 or 8
    std::uint8_t  endianness;    // 0=little, 1=big
    std::uint8_t  reserved;
};
----

=== 4. Use Hash Verification

[source,cpp]
----
// Sender
constexpr auto EXPECTED_HASH = get_layout_hash<MyType>();
// Include in protocol negotiation

// Receiver
if (received_hash != get_layout_hash<MyType>()) {
    throw std::runtime_error("Layout mismatch - incompatible platforms");
}
----

== Testing on Multiple Platforms

=== CI/CD Configuration

[source,yaml]
----
# GitHub Actions example
jobs:
  build:
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
        arch: [x64, arm64]
    
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v4
      - name: Build
        run: |
          cmake -B build -DCMAKE_CXX_COMPILER=clang++
          cmake --build build
      - name: Test
        run: ctest --test-dir build
----

=== Cross-Compilation

[source,bash]
----
# Cross-compile for ARM64 from x86_64
clang++ --target=aarch64-linux-gnu \
    -std=c++26 -freflection \
    -I/path/to/aarch64/sysroot/include \
    source.cpp -o app_arm64
----

== See Also

* xref:config/index.adoc[Configuration Overview]
* xref:config/compiler-options.adoc[Compiler Options]
* xref:../user-guide/portability.adoc[Portability Guide]
