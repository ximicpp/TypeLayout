= Quick Start
:navtitle: Quick Start

Get up and running with Boost.TypeLayout in 5 minutes.

== Prerequisites

=== Compiler

You need a {cpp26} compiler with P2996 static reflection support. Currently, only the Bloomberg Clang P2996 fork provides this:

* https://github.com/bloomberg/clang-p2996[Bloomberg Clang P2996 Fork]

=== Build Command

[source,bash]
----
clang++ -std=c++26 -freflection -freflection-latest -stdlib=libc++ your_code.cpp
----

== Installation

Boost.TypeLayout is header-only. Simply add the include directory to your project:

[source,bash]
----
# Clone the repository
git clone https://github.com/ximicpp/TypeLayout.git

# Add to your include path
-I/path/to/TypeLayout/include
----

Or with CMake:

[source,cmake]
----
add_subdirectory(TypeLayout)
target_link_libraries(your_target PRIVATE Boost::typelayout)
----

== Library Headers

Boost.TypeLayout provides three main headers for different use cases:

[cols="1,2"]
|===
| Header | Description

| `<boost/typelayout.hpp>`
| Core layer only - layout signature generation

| `<boost/typelayout/typelayout_util.hpp>`
| Utility layer - serialization safety analysis (includes core)

| `<boost/typelayout/typelayout_all.hpp>`
| Complete library - both core and utility
|===

== Basic Usage

=== Step 1: Include the Header

[source,cpp]
----
// For layout signature analysis only
#include <boost/typelayout.hpp>
using namespace boost::typelayout;
----

=== Step 2: Generate a Layout Signature

[source,cpp]
----
struct Point {
    int32_t x;
    int32_t y;
};

// Get the layout signature at compile time
constexpr auto sig = get_layout_signature<Point>();

// Print it at runtime (for debugging)
#include <iostream>
int main() {
    std::cout << sig.c_str() << std::endl;
    // Output: [64-le]struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}
}
----

=== Step 3: Bind a Type to Its Signature

[source,cpp]
----
// This static_assert will fail if the layout ever changes
TYPELAYOUT_BIND(Point, "[64-le]struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}");
----

=== Step 4: Check Serializability (Utility Layer)

[source,cpp]
----
// Include the utility layer for serialization checks
#include <boost/typelayout/typelayout_util.hpp>
using namespace boost::typelayout;

// Check if a type is safe for binary serialization
static_assert(Serializable<Point>);  // OK - uses fixed-width integers

struct BadStruct {
    wchar_t name[16];  // Platform-dependent size!
};
static_assert(!Serializable<BadStruct>);  // wchar_t has platform-dependent size
----

=== Step 5: Use Concepts for Template Constraints

[source,cpp]
----
// Core concepts - layout matching
template<typename T>
    requires LayoutMatch<T, "[64-le]struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}">
void process_point(const T& p) {
    // Safe to assume specific memory layout
}

// Utility concepts - serialization safety
template<Serializable T>
void safe_serialize(const T& obj) {
    // Can safely binary serialize
}

// Zero-copy transmission (serializable + trivially copyable + standard layout)
template<ZeroCopyTransmittable T>
void broadcast(const T& msg) {
    send_raw_bytes(&msg, sizeof(T));
}
----

== Complete Example: Core Layer Only

[source,cpp]
----
#include <boost/typelayout.hpp>
#include <iostream>
#include <cstdint>

using namespace boost::typelayout;

struct Point { int32_t x, y; };
struct Vec2 { int32_t x, y; };

// Layout compatibility check
static_assert(LayoutCompatible<Point, Vec2>, "Must have same layout");

// Hash-based verification
constexpr uint64_t POINT_HASH = get_layout_hash<Point>();
static_assert(LayoutHashMatch<Vec2, POINT_HASH>);

int main() {
    std::cout << "Point layout: " << get_layout_signature_cstr<Point>() << std::endl;
    std::cout << "Vec2 layout:  " << get_layout_signature_cstr<Vec2>() << std::endl;
    std::cout << "Hash: 0x" << std::hex << POINT_HASH << std::endl;
    return 0;
}
----

== Complete Example: With Utility Layer

[source,cpp]
----
#include <boost/typelayout/typelayout_util.hpp>
#include <iostream>
#include <cstdint>

using namespace boost::typelayout;

// Define a network message
struct NetworkMessage {
    uint32_t magic;
    uint32_t version;
    uint64_t timestamp;
    char payload[64];
};

// Bind to expected layout - compilation fails if layout differs
TYPELAYOUT_BIND(NetworkMessage,
    "[64-le]struct[s:80,a:8]{@0[magic]:u32[s:4,a:4],@4[version]:u32[s:4,a:4],@8[timestamp]:u64[s:8,a:8],@16[payload]:bytes[s:64,a:1]}");

// Verify serializability (utility layer)
static_assert(Serializable<NetworkMessage>, "NetworkMessage must be serializable");
static_assert(ZeroCopyTransmittable<NetworkMessage>, "NetworkMessage must be zero-copy safe");

// Get hash for runtime verification
constexpr uint64_t MESSAGE_HASH = get_layout_hash<NetworkMessage>();

int main() {
    std::cout << "Layout: " << get_layout_signature_cstr<NetworkMessage>() << std::endl;
    std::cout << "Hash: 0x" << std::hex << MESSAGE_HASH << std::endl;
    std::cout << "Size: " << sizeof(NetworkMessage) << " bytes" << std::endl;
    std::cout << "Serializable: " << std::boolalpha << is_serializable_v<NetworkMessage> << std::endl;
    return 0;
}
----

== What's Next?

* xref:user-guide/index.adoc[User Guide] - Learn all features in depth
* xref:user-guide/layout-signatures.adoc[Layout Signatures] - Understand signature format
* xref:user-guide/portability.adoc[Portability] - Cross-platform considerations
* xref:reference/index.adoc[API Reference] - Complete API documentation