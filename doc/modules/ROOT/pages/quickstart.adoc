= Quick Start
:navtitle: Quick Start

Get up and running with Boost.TypeLayout in 5 minutes.

== Why TypeLayout?

[IMPORTANT]
====
**The Core Guarantee**: Same Signature ‚ü∫ Same Memory Layout

This enables safe data sharing across:

* üîÑ **Processes** ‚Äî Shared memory, IPC
* üåê **Machines** ‚Äî Network protocols, file formats
* ‚è≥ **Time** ‚Äî Binary compatibility across versions
====

When two programs exchange raw bytes (through shared memory, network, or files), layout mismatches cause *silent data corruption*. TypeLayout prevents this at compile time‚Äîbefore your code even runs.

== Prerequisites

=== Compiler

You need a {cpp26} compiler with P2996 static reflection support. Currently, only the Bloomberg Clang P2996 fork provides this:

* https://github.com/bloomberg/clang-p2996[Bloomberg Clang P2996 Fork]

=== Build Command

[source,bash]
----
clang++ -std=c++26 -freflection -freflection-latest -stdlib=libc++ your_code.cpp
----

== Installation

Boost.TypeLayout is header-only. Simply add the include directory to your project:

[source,bash]
----
# Clone the repository
git clone https://github.com/ximicpp/TypeLayout.git

# Add to your include path
-I/path/to/TypeLayout/include
----

Or with CMake:

[source,cmake]
----
add_subdirectory(TypeLayout)
target_link_libraries(your_target PRIVATE Boost::typelayout)
----

== Library Headers

Boost.TypeLayout provides three main headers for different use cases:

[cols="1,2"]
|===
| Header | Description

| `<boost/typelayout.hpp>`
| Core layer only - layout signature generation

| `<boost/typelayout/typelayout_util.hpp>`
| Utility layer - serialization safety analysis (includes core)

| `<boost/typelayout/typelayout_all.hpp>`
| Complete library - both core and utility
|===

== Basic Usage

=== Step 1: Include the Header

[source,cpp]
----
// For layout signature analysis only
#include <boost/typelayout.hpp>
using namespace boost::typelayout;
----

=== Step 2: Generate a Layout Signature

[source,cpp]
----
struct Point {
    int32_t x;
    int32_t y;
};

// Get the layout signature at compile time
constexpr auto sig = get_layout_signature<Point>();

// Print it at runtime (for debugging)
#include <iostream>
int main() {
    std::cout << sig.c_str() << std::endl;
    // Output: [64-le]struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}
}
----

=== Step 3: Bind a Type to Its Signature

[source,cpp]
----
// This static_assert will fail if the layout ever changes
TYPELAYOUT_BIND(Point, "[64-le]struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}");
----

=== Step 4: Check Serializability (Utility Layer)

[source,cpp]
----
// Include the utility layer for serialization checks
#include <boost/typelayout/typelayout_util.hpp>
using namespace boost::typelayout;

// Check if a type is safe for binary serialization
static_assert(Serializable<Point>);  // OK - uses fixed-width integers

struct BadStruct {
    wchar_t name[16];  // Platform-dependent size!
};
static_assert(!Serializable<BadStruct>);  // wchar_t has platform-dependent size
----

=== Step 5: Use Concepts for Template Constraints

[source,cpp]
----
// Core concepts - layout matching
template<typename T>
    requires LayoutMatch<T, "[64-le]struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}">
void process_point(const T& p) {
    // Safe to assume specific memory layout
}

// Utility concepts - serialization safety
template<Serializable T>
void safe_serialize(const T& obj) {
    // Can safely binary serialize
}

// Zero-copy transmission (serializable + trivially copyable + standard layout)
template<ZeroCopyTransmittable T>
void broadcast(const T& msg) {
    send_raw_bytes(&msg, sizeof(T));
}
----

== Complete Example: Core Layer Only

[source,cpp]
----
#include <boost/typelayout.hpp>
#include <iostream>
#include <cstdint>

using namespace boost::typelayout;

struct Point { int32_t x, y; };
struct Vec2 { int32_t x, y; };

// Layout compatibility check
static_assert(LayoutCompatible<Point, Vec2>, "Must have same layout");

// Hash-based verification
constexpr uint64_t POINT_HASH = get_layout_hash<Point>();
static_assert(LayoutHashMatch<Vec2, POINT_HASH>);

int main() {
    std::cout << "Point layout: " << get_layout_signature_cstr<Point>() << std::endl;
    std::cout << "Vec2 layout:  " << get_layout_signature_cstr<Vec2>() << std::endl;
    std::cout << "Hash: 0x" << std::hex << POINT_HASH << std::endl;
    return 0;
}
----

== Classes with Private Members

TypeLayout fully supports `class` types with private members, constructors, and methods:

[source,cpp]
----
#include <boost/typelayout.hpp>
#include <iostream>
#include <cstdint>

using namespace boost::typelayout;

// Classes with private members - TypeLayout reflects ALL members
class Entity {
public:
    Entity(uint64_t id) : id_(id), active_(true) {}
    uint64_t getId() const { return id_; }
    bool isActive() const { return active_; }
    
private:
    uint64_t id_;    // Private member - still reflected!
    bool active_;    // Private member - still reflected!
};

// Polymorphic classes with virtual functions
class IShape {
public:
    virtual ~IShape() = default;
    virtual double area() const = 0;
protected:
    int32_t id_;
};

// Both are fully supported
static_assert(LayoutSupported<Entity>, "Classes are supported");
static_assert(LayoutSupported<IShape>, "Polymorphic classes are supported");

int main() {
    std::cout << "Entity layout: " << get_layout_signature_cstr<Entity>() << std::endl;
    // Output: [64-le]struct[s:16,a:8]{@0[id_]:u64[s:8,a:8],@8[active_]:bool[s:1,a:1]}
    
    std::cout << "IShape layout: " << get_layout_signature_cstr<IShape>() << std::endl;
    // Output: [64-le]class[s:16,a:8,polymorphic]{@8[id_]:i32[s:4,a:4]}
    
    return 0;
}
----

TIP: TypeLayout is *NOT* limited to `struct` or POD types. It supports classes with constructors, private members, inheritance, and virtual functions.

== Complete Example: With Utility Layer

[source,cpp]
----
#include <boost/typelayout/typelayout_util.hpp>
#include <iostream>
#include <cstdint>

using namespace boost::typelayout;

// Define a network message
struct NetworkMessage {
    uint32_t magic;
    uint32_t version;
    uint64_t timestamp;
    char payload[64];
};

// Bind to expected layout - compilation fails if layout differs
TYPELAYOUT_BIND(NetworkMessage,
    "[64-le]struct[s:80,a:8]{@0[magic]:u32[s:4,a:4],@4[version]:u32[s:4,a:4],@8[timestamp]:u64[s:8,a:8],@16[payload]:bytes[s:64,a:1]}");

// Verify serializability (utility layer)
static_assert(Serializable<NetworkMessage>, "NetworkMessage must be serializable");
static_assert(ZeroCopyTransmittable<NetworkMessage>, "NetworkMessage must be zero-copy safe");

// Get hash for runtime verification
constexpr uint64_t MESSAGE_HASH = get_layout_hash<NetworkMessage>();

int main() {
    std::cout << "Layout: " << get_layout_signature_cstr<NetworkMessage>() << std::endl;
    std::cout << "Hash: 0x" << std::hex << MESSAGE_HASH << std::endl;
    std::cout << "Size: " << sizeof(NetworkMessage) << " bytes" << std::endl;
    std::cout << "Serializable: " << std::boolalpha << is_serializable_v<NetworkMessage> << std::endl;
    return 0;
}
----

== What's Next?

* xref:user-guide/index.adoc[User Guide] - Learn all features in depth
* xref:user-guide/layout-signatures.adoc[Layout Signatures] - Understand signature format
* xref:user-guide/portability.adoc[Portability] - Cross-platform considerations
* xref:reference/index.adoc[API Reference] - Complete API documentation