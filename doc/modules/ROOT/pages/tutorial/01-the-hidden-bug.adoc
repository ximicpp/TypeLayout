= Chapter 1: The Hidden Bug
:navtitle: 1. The Hidden Bug

Why struct layout matters and the subtle bugs it can cause.

== A Simple Configuration File

Imagine you're building a game that saves player configuration to a file:

[source,cpp]
----
// game_config.hpp
struct GameConfig {
    int32_t  version;      // Config file version
    bool     fullscreen;   // Fullscreen mode?
    int64_t  last_played;  // Timestamp
    uint32_t volume;       // 0-100
};

void save_config(const GameConfig& cfg, const char* path) {
    std::ofstream file(path, std::ios::binary);
    file.write(reinterpret_cast<const char*>(&cfg), sizeof(cfg));
}

GameConfig load_config(const char* path) {
    GameConfig cfg;
    std::ifstream file(path, std::ios::binary);
    file.read(reinterpret_cast<char*>(&cfg), sizeof(cfg));
    return cfg;
}
----

This code looks correct. It compiles without warnings. It works on your machine.

**But there's a hidden bug.**

== The Bug Revealed

Let's examine the actual memory layout:

[source,cpp]
----
struct GameConfig {
    int32_t  version;      // offset 0, size 4
    bool     fullscreen;   // offset 4, size 1
    // 3 bytes padding here! (for int64_t alignment)
    int64_t  last_played;  // offset 8, size 8
    uint32_t volume;       // offset 16, size 4
    // 4 bytes padding here! (for struct alignment)
};
// Total size: 24 bytes, alignment: 8
----

The struct has **7 bytes of hidden padding**. Now consider these scenarios:

=== Scenario 1: Cross-Platform Sharing

[cols="2,1,1"]
|===
|Platform |`long` size |`bool` alignment

|Linux x86_64 (LP64)
|8 bytes
|1 byte

|Windows x64 (LLP64)
|4 bytes
|1 byte

|Some ARM platforms
|4 bytes
|4 bytes
|===

If a Linux server saves the config and a Windows client loads it... **data corruption**.

=== Scenario 2: Compiler Differences

Even on the same OS, different compilers may use different padding strategies:

* GCC vs Clang vs MSVC
* Debug vs Release builds
* Different optimization flags

=== Scenario 3: Code Evolution

A future developer adds a new field:

[source,cpp]
----
struct GameConfig {
    int32_t  version;
    bool     fullscreen;
    bool     vsync;        // NEW: VSync enabled?
    int64_t  last_played;
    uint32_t volume;
};
----

Old config files are now **silently incompatible**. No error, just wrong values.

== The Real-World Impact

These bugs are:

* **Silent** - No compiler warning, no runtime error
* **Intermittent** - Works on some platforms, fails on others
* **Hard to debug** - Data looks almost right but is slightly shifted

Common victims:

* Game save files
* Configuration persistence
* Shared memory between processes
* Network protocols
* Memory-mapped files

== What We Need

We need a way to:

1. **Capture** the exact memory layout of a struct at compile time
2. **Compare** layouts to detect incompatibilities before they cause bugs
3. **Verify** that layouts match expected specifications
4. **Do it all at compile time** - catch bugs before deployment

This is exactly what TypeLayout provides.

== Next Chapter

In xref:tutorial/02-the-old-ways.adoc[Chapter 2: The Old Ways], we'll explore traditional solutions to this problem and understand their limitations.
