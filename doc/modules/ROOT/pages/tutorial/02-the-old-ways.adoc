= Chapter 2: The Old Ways
:navtitle: 2. The Old Ways

Traditional solutions to struct layout problems and their limitations.

== Solution 1: Manual static_assert

The most common approach is manual offset verification:

[source,cpp]
----
struct GameConfig {
    int32_t  version;
    bool     fullscreen;
    int64_t  last_played;
    uint32_t volume;
};

// Manual verification
static_assert(sizeof(GameConfig) == 24);
static_assert(offsetof(GameConfig, version) == 0);
static_assert(offsetof(GameConfig, fullscreen) == 4);
static_assert(offsetof(GameConfig, last_played) == 8);
static_assert(offsetof(GameConfig, volume) == 16);
----

=== Limitations

[cols="1,2"]
|===
|Problem |Impact

|**Tedious**
|Must write one assertion per field

|**Error-prone**
|Easy to forget a field or make typos

|**Maintenance burden**
|Must update when struct changes

|**No private members**
|`offsetof` fails on non-standard-layout types

|**No inheritance**
|Cannot verify base class offsets
|===

== Solution 2: External Tools

Tools like `pahole` and `dwarfdump` can analyze compiled binaries:

[source,bash]
----
$ pahole -C GameConfig my_program
struct GameConfig {
    int32_t   version;          /*     0     4 */
    _Bool     fullscreen;       /*     4     1 */
    /* 3 bytes hole */
    int64_t   last_played;      /*     8     8 */
    uint32_t  volume;           /*    16     4 */
    /* 4 bytes padding */
    /* size: 24, alignment: 8 */
};
----

=== Limitations

[cols="1,2"]
|===
|Problem |Impact

|**Post-compilation**
|Only works after building

|**External dependency**
|Not part of C++ build process

|**Manual inspection**
|Must compare outputs yourself

|**No CI/CD integration**
|Hard to automate verification
|===

== Solution 3: Pragma Pack

Force specific alignment with compiler directives:

[source,cpp]
----
#pragma pack(push, 1)
struct GameConfig {
    int32_t  version;
    bool     fullscreen;
    int64_t  last_played;
    uint32_t volume;
};
#pragma pack(pop)
// Now size is exactly 17 bytes, no padding
----

=== Limitations

[cols="1,2"]
|===
|Problem |Impact

|**Performance penalty**
|Unaligned access is slower

|**Portability issues**
|Non-standard, varies by compiler

|**Invasive**
|Changes the actual layout

|**Alignment requirements**
|May violate CPU alignment needs
|===

== Solution 4: Serialization Libraries

Use protobuf, flatbuffers, or similar:

[source,protobuf]
----
// config.proto
message GameConfig {
    int32 version = 1;
    bool fullscreen = 2;
    int64 last_played = 3;
    uint32 volume = 4;
}
----

=== Limitations

[cols="1,2"]
|===
|Problem |Impact

|**IDL overhead**
|Separate definition language

|**Generated code**
|Not native C++ structs

|**Runtime cost**
|Serialization/deserialization overhead

|**Learning curve**
|New tools and concepts to learn
|===

== What We Really Need

An ideal solution would:

[cols="1,1,1,1,1"]
|===
|Feature |Manual |External |Pack |IDL

|Compile-time verification
|✅
|❌
|❌
|❌

|Zero runtime overhead
|✅
|✅
|❌
|❌

|Native C++ structs
|✅
|✅
|✅
|❌

|Automatic & complete
|❌
|❌
|✅
|✅

|Private member support
|❌
|✅
|✅
|N/A

|Inheritance support
|❌
|✅
|✅
|❌
|===

TypeLayout achieves **all of these** using C++26 static reflection.

== Next Chapter

In xref:tutorial/03-quick-start.adoc[Chapter 3: Quick Start], you'll write your first layout signature and see TypeLayout in action.
