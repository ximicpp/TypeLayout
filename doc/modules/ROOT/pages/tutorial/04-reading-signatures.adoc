= Chapter 4: Reading Signatures
:navtitle: 4. Reading Signatures

Understanding the layout signature format in detail.

== Signature Grammar

A layout signature follows this structure:

[source]
----
<signature> ::= <platform> <type-sig>

<platform>  ::= "[" <bits> "-" <endian> "]"
<bits>      ::= "32" | "64"
<endian>    ::= "le" | "be"

<type-sig>  ::= <primitive> | <struct-sig> | <class-sig> | 
                <union-sig> | <enum-sig> | <array-sig> | ...
----

== Platform Prefix

The platform prefix identifies the build environment:

[cols="1,3"]
|===
|Prefix |Meaning

|`[64-le]`
|64-bit, little-endian (x86_64, ARM64)

|`[64-be]`
|64-bit, big-endian (POWER, SPARC)

|`[32-le]`
|32-bit, little-endian (x86)

|`[32-be]`
|32-bit, big-endian (older ARM)
|===

== Primitive Types

[cols="2,1,1,3"]
|===
|Type |Signature |Size |Notes

|`int8_t`
|`i8[s:1,a:1]`
|1
|Signed 8-bit

|`uint16_t`
|`u16[s:2,a:2]`
|2
|Unsigned 16-bit

|`int32_t`
|`i32[s:4,a:4]`
|4
|Signed 32-bit

|`int64_t`
|`i64[s:8,a:8]`
|8
|Signed 64-bit

|`float`
|`f32[s:4,a:4]`
|4
|IEEE 754 single

|`double`
|`f64[s:8,a:8]`
|8
|IEEE 754 double

|`bool`
|`bool[s:1,a:1]`
|1
|Boolean

|`char`
|`char[s:1,a:1]`
|1
|Character

|`void*`
|`ptr[s:8,a:8]`
|4/8
|Platform-dependent
|===

== Struct Signatures

=== Basic Format

[source]
----
struct[s:SIZE,a:ALIGN]{FIELDS}
----

Example:
[source,cpp]
----
struct Point { int32_t x, y; };
// [64-le]struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}
----

=== Field Format

Each field has:
[source]
----
@OFFSET[NAME]:TYPE
----

* `@OFFSET` - Byte offset from struct start
* `[NAME]` - Field name
* `TYPE` - Field type signature

=== With Padding

[source,cpp]
----
struct Padded {
    int8_t  a;   // @0
    // 3 bytes padding (for int32_t alignment)
    int32_t b;   // @4
};
// struct[s:8,a:4]{@0[a]:i8[s:1,a:1],@4[b]:i32[s:4,a:4]}
----

The padding is **implicit** - inferred from the gap between offsets.

== Class Signatures

Classes with inheritance or polymorphism use the `class` keyword:

=== With Inheritance

[source,cpp]
----
struct Base { uint64_t id; };
struct Derived : Base { uint32_t value; };
// class[s:16,a:8,inherited]{@0[base]:struct[s:8,a:8]{...},@8[value]:u32[s:4,a:4]}
----

The `inherited` marker indicates the class has base classes.

=== Polymorphic Classes

[source,cpp]
----
class Entity {
    virtual ~Entity() = default;
    uint32_t id_;
};
// class[s:16,a:8,polymorphic]{@8[id_]:u32[s:4,a:4]}
----

The `polymorphic` marker indicates a vtable pointer exists (offset 0-7).

== Union Signatures

All union members share offset 0:

[source,cpp]
----
union Value {
    int32_t i;
    float   f;
};
// union[s:4,a:4]{@0[i]:i32[s:4,a:4],@0[f]:f32[s:4,a:4]}
----

== Enum Signatures

Enums include their underlying type:

[source,cpp]
----
enum class Color : uint8_t { Red, Green, Blue };
// enum[s:1,a:1]<u8[s:1,a:1]>
----

== Array Signatures

Arrays include element type and count:

[source,cpp]
----
int32_t arr[4];
// array[s:16,a:4]<i32[s:4,a:4],4>
----

Special case for `char` arrays:
[source,cpp]
----
char buf[64];
// bytes[s:64,a:1]
----

== Bitfield Signatures

Bitfields use a special format:

[source,cpp]
----
struct Flags {
    uint8_t a : 3;
    uint8_t b : 5;
};
// struct[s:1,a:1]{@0.0[a]:bits<3,u8[s:1,a:1]>,@0.3[b]:bits<5,u8[s:1,a:1]>}
----

* `@0.0` - byte 0, bit 0
* `@0.3` - byte 0, bit 3
* `bits<WIDTH,TYPE>` - bitfield width and underlying type

== Anonymous Members

Anonymous unions/structs get placeholder names:

[source,cpp]
----
struct Mixed {
    int32_t x;
    union { int32_t a; float b; };  // Anonymous union
};
// struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[<anon:0>]:union[s:4,a:4]{...}}
----

== Signature Comparison Rules

Two signatures are equal if and only if:

1. Platform prefix matches
2. Type category matches
3. Size and alignment match
4. All field offsets match
5. All field names match
6. All field types match (recursively)

IMPORTANT: Field **names** are part of the signature. Different names = different signature.

== Next Chapter

In xref:tutorial/05-real-world.adoc[Chapter 5: Real-World Applications], we'll apply these concepts to practical scenarios.
