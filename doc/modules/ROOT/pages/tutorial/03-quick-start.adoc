= Chapter 3: Quick Start
:navtitle: 3. Quick Start

Your first layout signature with TypeLayout.

== Installation

TypeLayout is a header-only library. Simply include the header:

[source,cpp]
----
#include <boost/typelayout.hpp>
using namespace boost::typelayout;
----

NOTE: Requires a C++26 compiler with P2996 static reflection support.

== Your First Signature

Let's generate a layout signature for a simple struct:

[source,cpp]
----
#include <boost/typelayout.hpp>
#include <cstdint>

using namespace boost::typelayout;

struct Point {
    int32_t x;
    int32_t y;
};

int main() {
    // Generate signature at compile time
    constexpr auto sig = get_layout_signature<Point>();
    
    // Print it (at runtime, for inspection)
    std::println("Point signature: {}", sig.c_str());
}
----

Output:
[source]
----
Point signature: [64-le]struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}
----

== Understanding the Signature

Let's break down what this signature tells us:

[source]
----
[64-le]struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}
│       │     │   │   │ │ │   │         │
│       │     │   │   │ │ │   │         └─ Second field info
│       │     │   │   │ │ │   └─ Type signature
│       │     │   │   │ │ └─ Field name
│       │     │   │   │ └─ Offset in bytes
│       │     │   │   └─ Field list start
│       │     │   └─ Alignment
│       │     └─ Size
│       └─ Type category
└─ Platform prefix
----

== Compile-Time Verification

The real power is compile-time verification:

[source,cpp]
----
struct Point {
    int32_t x;
    int32_t y;
};

// Verify layout at compile time - fails if layout changes
static_assert(get_layout_signature<Point>() == 
    "[64-le]struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}");

// Or use the convenient macro
BOOST_TYPELAYOUT_ASSERT(Point,
    "[64-le]struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}");
----

If anyone changes `Point` (even accidentally), compilation fails immediately.

== Comparing Types

Check if two types have the same memory layout:

[source,cpp]
----
struct PointA { int32_t x, y; };
struct PointB { int32_t a, b; };  // Different names, same layout
struct PointC { int64_t x, y; };  // Different types

// These pass
static_assert(LayoutCompatible<PointA, PointA>);  // Same type
// Note: PointA and PointB have different field names, so not compatible
static_assert(!LayoutCompatible<PointA, PointB>); // Different field names

// This fails (different sizes)
static_assert(!LayoutCompatible<PointA, PointC>);
----

== Using Hash for Quick Checks

For runtime comparison, use the 64-bit hash:

[source,cpp]
----
constexpr auto hash = get_layout_hash<Point>();
// Returns a 64-bit FNV-1a hash of the signature

// Useful in headers, IPC, shared memory:
struct SharedMemoryHeader {
    uint64_t layout_hash;  // Store hash for verification
    // ... data ...
};
----

== Exercise: Try It Yourself

1. Create a struct with padding:
+
[source,cpp]
----
struct Padded {
    int8_t  a;
    int32_t b;
};
----

2. Generate its signature
3. Predict the size and offsets before checking
4. Verify your predictions with `static_assert`

== Next Chapter

In xref:tutorial/04-reading-signatures.adoc[Chapter 4: Reading Signatures], we'll dive deeper into the signature format and learn to read complex signatures.
