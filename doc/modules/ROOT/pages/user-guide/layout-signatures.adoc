= Layout Signatures
:navtitle: Layout Signatures

A *layout signature* is a human-readable string that uniquely identifies the memory layout of a type. It captures size, alignment, member offsets, and type information in a compact format.

== Signature Format

The general format of a layout signature is:

[source]
----
[ARCH]KIND[s:SIZE,a:ALIGN]\{CONTENT\}
----

Where:

* `[ARCH]` - Architecture descriptor (e.g., `[64-le]` for 64-bit little-endian)
* `KIND` - The type category (`struct`, `union`, `array`, or fundamental type)
* `[s:SIZE,a:ALIGN]` - Size in bytes and alignment requirement
* `\{CONTENT\}` - Member or element information

== Architecture Descriptor

The architecture descriptor captures platform-specific information:

[cols="1,2"]
|===
| Component | Description

| Bit width
| `32` or `64` for pointer size

| Byte order
| `le` (little-endian) or `be` (big-endian)
|===

Examples:

* `[64-le]` - 64-bit little-endian (x86-64, ARM64 default)
* `[32-le]` - 32-bit little-endian (x86)
* `[64-be]` - 64-bit big-endian (PowerPC64)

== Fundamental Types

Fundamental types use short identifiers:

[cols="1,2,1"]
|===
| Identifier | Type | Typical Size

| `i8`, `i16`, `i32`, `i64`
| Signed integers (fixed-width)
| 1, 2, 4, 8 bytes

| `u8`, `u16`, `u32`, `u64`
| Unsigned integers (fixed-width)
| 1, 2, 4, 8 bytes

| `f32`, `f64`
| Floating point
| 4, 8 bytes

| `bool`
| Boolean
| 1 byte

| `char`, `schar`, `uchar`
| Character types
| 1 byte

| `wchar`
| Wide character
| Platform-dependent

| `char8`, `char16`, `char32`
| Unicode character types
| 1, 2, 4 bytes

| `ptr`
| Pointer
| Platform-dependent

| `long`, `ulong`
| Long integer (platform-dependent)
| 4 or 8 bytes

| `ldouble`
| Long double (platform-dependent)
| 8, 12, or 16 bytes
|===

== Struct Signatures

A struct signature includes all non-static data members with their offsets:

[source]
----
[64-le]struct[s:SIZE,a:ALIGN]{@OFF1[name1]:TYPE1,@OFF2[name2]:TYPE2,...}
----

Example for a simple `Point` struct:

[source,cpp]
----
struct Point {
    int x;
    int y;
};
----

Signature:
[source]
----
[64-le]struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}
----

Breaking it down:

* `[64-le]` - 64-bit little-endian platform
* `struct[s:8,a:4]` - Total size 8 bytes, alignment 4 bytes
* `@0[x]:i32[s:4,a:4]` - Member `x` at offset 0, 32-bit signed integer
* `@4[y]:i32[s:4,a:4]` - Member `y` at offset 4, 32-bit signed integer

== Padding Detection

Padding appears as gaps in offsets. Consider:

[source,cpp]
----
struct Padded {
    char c;     // offset 0
    // 3 bytes padding
    int i;      // offset 4
};
----

Signature:
[source]
----
[64-le]struct[s:8,a:4]{@0[c]:char[s:1,a:1],@4[i]:i32[s:4,a:4]}
----

The gap between offset 0 (size 1) and offset 4 reveals 3 bytes of padding.

== Union Signatures

Unions follow the same format but use `union` as the kind:

[source,cpp]
----
union Data {
    int i;
    float f;
};
----

Signature:
[source]
----
[64-le]union[s:4,a:4]{@0[i]:i32[s:4,a:4],@0[f]:f32[s:4,a:4]}
----

Note that all members have offset `@0` since they share the same storage.

== Array Signatures

Arrays use the `array` kind with element count:

[source,cpp]
----
int arr[10];
----

Signature:
[source]
----
[64-le]array<10>[s:40,a:4]{i32[s:4,a:4]}
----

== Nested Structures

Nested types are recursively expanded:

[source,cpp]
----
struct Inner {
    int value;
};

struct Outer {
    Inner inner;
    int extra;
};
----

Outer's signature:
[source]
----
[64-le]struct[s:8,a:4]{@0[inner]:struct[s:4,a:4]{@0[value]:i32[s:4,a:4]},@4[extra]:i32[s:4,a:4]}
----

== Obtaining Signatures

Use `get_layout_signature<T>()` to obtain a type's signature:

[source,cpp]
----
#include <boost/typelayout.hpp>
#include <iostream>

struct Point { int x, y; };

int main() {
    constexpr auto sig = boost::typelayout::get_layout_signature<Point>();
    std::cout << sig << '\n';
}
----

== Compile-Time Usage

Signatures are `constexpr` and can be used at compile time:

[source,cpp]
----
static_assert(
    boost::typelayout::get_layout_signature<Point>() ==
    "[64-le]struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}"
);
----

== See Also

* xref:user-guide/type-support.adoc[Type Support] - Complete list of supported types
* xref:user-guide/portability.adoc[Portability] - Platform-dependent type handling
* xref:user-guide/inheritance.adoc[Inheritance] - How base classes are represented
