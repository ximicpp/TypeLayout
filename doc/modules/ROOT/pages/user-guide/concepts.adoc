= Concepts
:navtitle: Concepts

Boost.TypeLayout provides {cpp20} concepts to constrain templates based on type layout properties.

== Available Concepts

[cols="1,2"]
|===
| Concept | Description

| `Serializable<T>`
| Type is safe for binary serialization (no platform-dependent or non-serializable members)

| `LayoutCompatible<T, U>`
| Two types have identical memory layouts

| `LayoutMatch<T, Sig>`
| Type's layout matches the given signature

| `LayoutHashMatch<T, Hash>`
| Type's layout hash matches the given value
|===

== Serializable

The `Serializable` concept checks if a type is safe for binary serialization, meaning it has no platform-dependent sizes, pointers, bit-fields, or other non-serializable members:

[source,cpp]
----
template<typename T>
concept Serializable = is_serializable_v<T, PlatformSet::current()>;
----

=== Usage

[source,cpp]
----
#include <boost/typelayout.hpp>

// Constrain a function to only accept serializable types
template<boost::typelayout::Serializable T>
void write_to_file(const T& data, std::ostream& out) {
    out.write(reinterpret_cast<const char*>(&data), sizeof(T));
}

// Constrain a class template
template<boost::typelayout::Serializable T>
class NetworkBuffer {
    T data_;
public:
    std::span<const std::byte> as_bytes() const {
        return std::as_bytes(std::span{&data_, 1});
    }
};
----

=== Example

[source,cpp]
----
struct SerializablePoint {
    std::int32_t x;
    std::int32_t y;
};

struct NonSerializablePoint {
    long x;  // Platform-dependent size!
    long y;
};

static_assert(boost::typelayout::Serializable<SerializablePoint>);
static_assert(!boost::typelayout::Serializable<NonSerializablePoint>);

NetworkBuffer<SerializablePoint> buf1;      // OK
// NetworkBuffer<NonSerializablePoint> buf2; // Error: constraint not satisfied
----

== LayoutCompatible

The `LayoutCompatible` concept checks if two types have identical memory layouts:

[source,cpp]
----
template<typename T, typename U>
concept LayoutCompatible = signatures_match<T, U>();
----

=== Usage

[source,cpp]
----
#include <boost/typelayout.hpp>

// Safely reinterpret between layout-compatible types
template<typename Target, typename Source>
    requires boost::typelayout::LayoutCompatible<Target, Source>
Target& reinterpret_as(Source& source) {
    return *reinterpret_cast<Target*>(&source);
}

// Type-safe union alternative
template<typename T, typename U>
    requires boost::typelayout::LayoutCompatible<T, U>
class LayoutUnion {
    alignas(T) std::byte storage_[sizeof(T)];
public:
    T& as_t() { return *reinterpret_cast<T*>(storage_); }
    U& as_u() { return *reinterpret_cast<U*>(storage_); }
};
----

=== Example

[source,cpp]
----
struct Point2D {
    float x;
    float y;
};

struct Vector2D {
    float dx;
    float dy;
};

struct Color {
    std::uint8_t r, g, b, a;
};

static_assert(boost::typelayout::LayoutCompatible<Point2D, Vector2D>);
static_assert(!boost::typelayout::LayoutCompatible<Point2D, Color>);

Point2D point{1.0f, 2.0f};
Vector2D& vec = reinterpret_as<Vector2D>(point);  // Safe reinterpret
----

== LayoutMatch

The `LayoutMatch` concept checks if a type's layout matches a compile-time signature string:

[source,cpp]
----
template<typename T, CompileString Sig>
concept LayoutMatch = get_layout_signature<T>() == Sig;
----

=== Usage

[source,cpp]
----
#include <boost/typelayout.hpp>

// Enforce specific layout at compile time
template<typename T>
    requires boost::typelayout::LayoutMatch<T, 
        "[64-le]struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}">
void process_point(const T& point) {
    // Guaranteed to have specific layout
}
----

=== Example

[source,cpp]
----
struct Point {
    int x;
    int y;
};

constexpr auto expected = 
    "[64-le]struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}"_cs;

static_assert(boost::typelayout::LayoutMatch<Point, expected>);
----

== LayoutHashMatch

The `LayoutHashMatch` concept checks if a type's layout hash matches a given value:

[source,cpp]
----
template<typename T, std::uint64_t Hash>
concept LayoutHashMatch = get_layout_hash<T>() == Hash;
----

This is useful when you want to verify layout without embedding the full signature string.

=== Usage

[source,cpp]
----
#include <boost/typelayout.hpp>

// Known hash value from reference implementation
constexpr std::uint64_t PACKET_LAYOUT_HASH = 0x1234567890ABCDEF;

template<typename T>
    requires boost::typelayout::LayoutHashMatch<T, PACKET_LAYOUT_HASH>
void send_packet(const T& packet) {
    // Layout verified by hash
}
----

=== Example

[source,cpp]
----
struct NetworkPacket {
    std::uint32_t type;
    std::uint32_t length;
    std::uint64_t timestamp;
};

constexpr auto hash = boost::typelayout::get_layout_hash<NetworkPacket>();

// Verify in another compilation unit or platform
static_assert(boost::typelayout::LayoutHashMatch<NetworkPacket, hash>);
----

== Combining Concepts

Concepts can be combined for complex constraints:

[source,cpp]
----
#include <boost/typelayout.hpp>

template<typename T>
concept SerializableMessage = 
    boost::typelayout::Serializable<T> &&
    std::is_trivially_copyable_v<T> &&
    (sizeof(T) <= 1024);

template<SerializableMessage T>
class MessageQueue {
    // Only accepts serializable, trivially copyable types under 1KB
};
----

== Concept Error Messages

When a concept constraint fails, you'll get a clear compile-time error:

[source,cpp]
----
struct BadType {
    long value;  // Non-serializable: platform-dependent size
};

template<boost::typelayout::Serializable T>
void process(T) {}

process(BadType{});  // Error!
----

Error message (example):
[source]
----
error: constraints not satisfied for 'void process(T) [with T = BadType]'
note: because 'boost::typelayout::Serializable<BadType>' evaluated to false
note: because 'boost::typelayout::is_serializable_v<BadType, ...>' evaluated to false
----

== Defining Custom Concepts

You can define custom concepts using the library's primitives:

[source,cpp]
----
#include <boost/typelayout.hpp>

// Type must be serializable (no bit-fields, pointers, platform-dependent types)
template<typename T>
concept CleanLayout = 
    boost::typelayout::Serializable<T>;

// Type must be compatible with a specific protocol version
template<typename T>
concept ProtocolV1Compatible = 
    boost::typelayout::LayoutHashMatch<T, PROTOCOL_V1_LAYOUT_HASH>;

// Type must have the same layout as a reference type
template<typename T>
concept SameAsPoint = 
    boost::typelayout::LayoutCompatible<T, Point>;
----

== Using Concepts with requires Clauses

[source,cpp]
----
#include <boost/typelayout.hpp>

class Serializer {
public:
    template<typename T>
    void write(const T& value) requires boost::typelayout::Serializable<T> {
        // Write serializable type
    }
    
    template<typename T>
    void write(const T& value) requires (!boost::typelayout::Serializable<T>) {
        // Handle non-serializable type differently
        static_assert(false, "Cannot serialize non-serializable types directly");
    }
};
----

== See Also

* xref:user-guide/portability.adoc[Portability] - Portability checking details
* xref:user-guide/hash-verification.adoc[Hash Verification] - Hash-based verification
* xref:../reference/concepts.adoc[API Reference: Concepts] - Full concept specifications
