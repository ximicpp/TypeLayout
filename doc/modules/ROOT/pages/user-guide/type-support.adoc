= Type Support
:navtitle: Type Support

Boost.TypeLayout supports a comprehensive range of {cpp} types. This page documents all supported types and their signature representations.

== Fundamental Types

=== Integer Types

[cols="1,1,2"]
|===
| Type | Signature | Notes

| `bool`
| `bool[s:1,a:1]`
| Always 1 byte

| `char`
| `char[s:1,a:1]`
| Character type

| `signed char`
| `schar[s:1,a:1]`
| Explicitly signed

| `unsigned char`
| `uchar[s:1,a:1]`
| Explicitly unsigned

| `short`
| `i16[s:2,a:2]`
| 16-bit signed

| `unsigned short`
| `u16[s:2,a:2]`
| 16-bit unsigned

| `int`
| `i32[s:4,a:4]`
| 32-bit signed

| `unsigned int`
| `u32[s:4,a:4]`
| 32-bit unsigned

| `long`
| `long[s:N,a:N]`
| Platform-dependent (4 or 8 bytes)

| `unsigned long`
| `ulong[s:N,a:N]`
| Platform-dependent

| `long long`
| `i64[s:8,a:8]`
| 64-bit signed

| `unsigned long long`
| `u64[s:8,a:8]`
| 64-bit unsigned
|===

=== Fixed-Width Integer Types

[cols="1,1"]
|===
| Type | Signature

| `std::int8_t`
| `i8[s:1,a:1]`

| `std::int16_t`
| `i16[s:2,a:2]`

| `std::int32_t`
| `i32[s:4,a:4]`

| `std::int64_t`
| `i64[s:8,a:8]`

| `std::uint8_t`
| `u8[s:1,a:1]`

| `std::uint16_t`
| `u16[s:2,a:2]`

| `std::uint32_t`
| `u32[s:4,a:4]`

| `std::uint64_t`
| `u64[s:8,a:8]`
|===

=== Floating-Point Types

[cols="1,1,2"]
|===
| Type | Signature | Notes

| `float`
| `f32[s:4,a:4]`
| IEEE 754 single precision

| `double`
| `f64[s:8,a:8]`
| IEEE 754 double precision

| `long double`
| `ldouble[s:N,a:N]`
| Platform-dependent (8, 12, or 16 bytes)
|===

=== Character Types

[cols="1,1,2"]
|===
| Type | Signature | Notes

| `char`
| `char[s:1,a:1]`
| Signedness is implementation-defined

| `wchar_t`
| `wchar[s:N,a:N]`
| Platform-dependent (2 or 4 bytes)

| `char8_t`
| `char8[s:1,a:1]`
| UTF-8 character (C++20)

| `char16_t`
| `char16[s:2,a:2]`
| UTF-16 character

| `char32_t`
| `char32[s:4,a:4]`
| UTF-32 character
|===

=== Special Types

[cols="1,1,2"]
|===
| Type | Signature | Notes

| `void*` (any pointer)
| `ptr[s:N,a:N]`
| 4 bytes (32-bit) or 8 bytes (64-bit)

| `std::nullptr_t`
| `nullptr[s:N,a:N]`
| Same as pointer size

| `std::byte`
| `byte[s:1,a:1]`
| C++17 byte type
|===

== Compound Types

=== Structs and Classes

Structs and classes generate signatures containing all non-static data members:

[source,cpp]
----
struct Example {
    int a;
    double b;
    char c;
};
----

[source]
----
[64-le]struct[s:24,a:8]{@0[a]:i32[s:4,a:4],@8[b]:f64[s:8,a:8],@16[c]:char[s:1,a:1]}
----

NOTE: Size is 24 due to alignment padding.

=== Unions

Unions work similarly but all members share offset 0:

[source,cpp]
----
union Variant {
    int i;
    double d;
};
----

[source]
----
[64-le]union[s:8,a:8]{@0[i]:i32[s:4,a:4],@0[d]:f64[s:8,a:8]}
----

=== Arrays

Arrays include element count and element type:

[source,cpp]
----
struct ArrayExample {
    int values[4];
};
----

[source]
----
[64-le]struct[s:16,a:4]{@0[values]:array<4>[s:16,a:4]{i32[s:4,a:4]}}
----

=== Multi-Dimensional Arrays

Multi-dimensional arrays are represented with nested array notation:

[source,cpp]
----
struct Matrix {
    int data[3][4];
};
----

[source]
----
[64-le]struct[s:48,a:4]{@0[data]:array<3>[s:48,a:4]{array<4>[s:16,a:4]{i32[s:4,a:4]}}}
----

=== Nested Types

Nested structures are fully expanded inline:

[source,cpp]
----
struct Point { int x, y; };
struct Rectangle {
    Point topLeft;
    Point bottomRight;
};
----

[source]
----
[64-le]struct[s:16,a:4]{@0[topLeft]:struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]},@8[bottomRight]:struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}}
----

== Platform-Dependent Types

Some types have different sizes on different platforms. These are flagged as *non-portable*:

[cols="1,2,2"]
|===
| Type | Windows x64 | Linux x64

| `long`
| 4 bytes
| 8 bytes

| `unsigned long`
| 4 bytes
| 8 bytes

| `wchar_t`
| 2 bytes
| 4 bytes

| `long double`
| 8 bytes
| 16 bytes
|===

Use `is_portable<T>()` to check if a type contains platform-dependent members:

[source,cpp]
----
struct PortableData {
    std::int32_t value;  // Portable
};

struct NonPortableData {
    long value;          // Non-portable!
};

static_assert(boost::typelayout::is_portable<PortableData>());
static_assert(!boost::typelayout::is_portable<NonPortableData>());
----

== Unsupported Types

The following types are currently not supported:

* Pointer-to-member types
* Function pointers (treated as opaque pointers)
* Reference types (use pointer instead)
* Volatile-qualified types
* Types with virtual functions (vtable affects layout)

== Type Qualifiers

=== const

`const` qualification does not affect layout:

[source,cpp]
----
// Both generate identical signatures
get_layout_signature<int>();
get_layout_signature<const int>();
----

=== volatile

`volatile` types are not supported as they often indicate special memory semantics.

== Empty Types

Empty structs have size 1 (per {cpp} standard):

[source,cpp]
----
struct Empty {};
----

[source]
----
[64-le]struct[s:1,a:1]{}
----

== See Also

* xref:user-guide/layout-signatures.adoc[Layout Signatures] - Signature format details
* xref:user-guide/portability.adoc[Portability] - Platform-dependent type handling
* xref:user-guide/bitfields.adoc[Bit-fields] - Bit-field support
