= Type Support
:navtitle: Type Support

Boost.TypeLayout supports a comprehensive range of {cpp} types. This page documents all supported types and their signature representations.

== Fundamental Types

=== Integer Types

[cols="1,1,2"]
|===
| Type | Signature | Notes

| `bool`
| `bool[s:1,a:1]`
| Always 1 byte

| `char`
| `char[s:1,a:1]`
| Character type

| `signed char`
| `schar[s:1,a:1]`
| Explicitly signed

| `unsigned char`
| `uchar[s:1,a:1]`
| Explicitly unsigned

| `short`
| `i16[s:2,a:2]`
| 16-bit signed

| `unsigned short`
| `u16[s:2,a:2]`
| 16-bit unsigned

| `int`
| `i32[s:4,a:4]`
| 32-bit signed

| `unsigned int`
| `u32[s:4,a:4]`
| 32-bit unsigned

| `long`
| `long[s:N,a:N]`
| Platform-dependent (4 or 8 bytes)

| `unsigned long`
| `ulong[s:N,a:N]`
| Platform-dependent

| `long long`
| `i64[s:8,a:8]`
| 64-bit signed

| `unsigned long long`
| `u64[s:8,a:8]`
| 64-bit unsigned
|===

=== Fixed-Width Integer Types

[cols="1,1"]
|===
| Type | Signature

| `std::int8_t`
| `i8[s:1,a:1]`

| `std::int16_t`
| `i16[s:2,a:2]`

| `std::int32_t`
| `i32[s:4,a:4]`

| `std::int64_t`
| `i64[s:8,a:8]`

| `std::uint8_t`
| `u8[s:1,a:1]`

| `std::uint16_t`
| `u16[s:2,a:2]`

| `std::uint32_t`
| `u32[s:4,a:4]`

| `std::uint64_t`
| `u64[s:8,a:8]`
|===

=== Floating-Point Types

[cols="1,1,2"]
|===
| Type | Signature | Notes

| `float`
| `f32[s:4,a:4]`
| IEEE 754 single precision

| `double`
| `f64[s:8,a:8]`
| IEEE 754 double precision

| `long double`
| `ldouble[s:N,a:N]`
| Platform-dependent (8, 12, or 16 bytes)
|===

=== Character Types

[cols="1,1,2"]
|===
| Type | Signature | Notes

| `char`
| `char[s:1,a:1]`
| Signedness is implementation-defined

| `wchar_t`
| `wchar[s:N,a:N]`
| Platform-dependent (2 or 4 bytes)

| `char8_t`
| `char8[s:1,a:1]`
| UTF-8 character (C++20)

| `char16_t`
| `char16[s:2,a:2]`
| UTF-16 character

| `char32_t`
| `char32[s:4,a:4]`
| UTF-32 character
|===

=== Special Types

[cols="1,1,2"]
|===
| Type | Signature | Notes

| `void*` (any pointer)
| `ptr[s:N,a:N]`
| 4 bytes (32-bit) or 8 bytes (64-bit)

| `std::nullptr_t`
| `nullptr[s:N,a:N]`
| Same as pointer size

| `std::byte`
| `byte[s:1,a:1]`
| C++17 byte type
|===

== Compound Types

=== Structs and Classes

Structs and classes generate signatures containing all non-static data members:

[source,cpp]
----
struct Example {
    int a;
    double b;
    char c;
};
----

[source]
----
[64-le]struct[s:24,a:8]{@0[a]:i32[s:4,a:4],@8[b]:f64[s:8,a:8],@16[c]:char[s:1,a:1]}
----

NOTE: Size is 24 due to alignment padding.

=== Unions

Unions work similarly but all members share offset 0:

[source,cpp]
----
union Variant {
    int i;
    double d;
};
----

[source]
----
[64-le]union[s:8,a:8]{@0[i]:i32[s:4,a:4],@0[d]:f64[s:8,a:8]}
----

=== Arrays

Arrays include element count and element type:

[source,cpp]
----
struct ArrayExample {
    int values[4];
};
----

[source]
----
[64-le]struct[s:16,a:4]{@0[values]:array<4>[s:16,a:4]{i32[s:4,a:4]}}
----

=== Multi-Dimensional Arrays

Multi-dimensional arrays are represented with nested array notation:

[source,cpp]
----
struct Matrix {
    int data[3][4];
};
----

[source]
----
[64-le]struct[s:48,a:4]{@0[data]:array<3>[s:48,a:4]{array<4>[s:16,a:4]{i32[s:4,a:4]}}}
----

=== Nested Types

Nested structures are fully expanded inline:

[source,cpp]
----
struct Point { int x, y; };
struct Rectangle {
    Point topLeft;
    Point bottomRight;
};
----

[source]
----
[64-le]struct[s:16,a:4]{@0[topLeft]:struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]},@8[bottomRight]:struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}}
----

== Platform-Dependent Types

Some types have different sizes on different platforms. These are flagged as *non-serializable*:

[cols="1,2,2"]
|===
| Type | Windows x64 (LLP64) | Linux x64 (LP64)

| `long`
| 4 bytes
| 8 bytes

| `unsigned long`
| 4 bytes
| 8 bytes

| `wchar_t`
| 2 bytes
| 4 bytes

| `long double`
| 8 bytes
| 16 bytes
|===

Use `is_serializable_v<T, P>` to check if a type is safe for binary serialization on a target `PlatformSet`:

[source,cpp]
----
struct SerializableData {
    std::int32_t value;  // Fixed-width, platform-independent
};

struct NonSerializableData {
    long value;          // Platform-dependent size!
};

static_assert(boost::typelayout::is_serializable_v<SerializableData, PlatformSet::bits64_le()>);
static_assert(!boost::typelayout::is_serializable_v<NonSerializableData, PlatformSet::bits64_le()>);
----

== Standard Library Types

Boost.TypeLayout provides specialized support for common standard library types to ensure consistent and readable signatures.

=== std::array

`std::array<T, N>` generates a dedicated signature format that clearly identifies it as a standard array container:

[source,cpp]
----
#include <array>

struct ArrayHolder {
    std::array<int, 4> data;
};
----

[source]
----
std_array[s:16,a:4]<i32[s:4,a:4],4>
----

The signature format is: `std_array[s:SIZE,a:ALIGN]<ELEMENT_TYPE,COUNT>`

Nested arrays are also supported:

[source,cpp]
----
std::array<std::array<int, 3>, 2> matrix;  // 2x3 matrix
----

[source]
----
std_array[s:24,a:4]<std_array[s:12,a:4]<i32[s:4,a:4],3>,2>
----

=== std::pair

`std::pair<T1, T2>` generates a signature that includes both element types:

[source,cpp]
----
#include <utility>

std::pair<int, double> coord;
----

[source]
----
pair[s:16,a:8]{i32[s:4,a:4],f64[s:8,a:8]}
----

The signature format is: `pair[s:SIZE,a:ALIGN]{FIRST_TYPE,SECOND_TYPE}`

Nested pairs work correctly:

[source,cpp]
----
std::pair<int, std::pair<char, bool>> nested;
----

[source]
----
pair[s:8,a:4]{i32[s:4,a:4],pair[s:2,a:1]{char[s:1,a:1],bool[s:1,a:1]}}
----

=== std::span (C++20)

`std::span<T, Extent>` is supported for both static and dynamic extent:

[source,cpp]
----
#include <span>

std::span<int, 10> static_span;   // Static extent
std::span<int> dynamic_span;      // Dynamic extent
----

Static extent signature:
[source]
----
span[s:8,a:8]<i32[s:4,a:4],10>
----

Dynamic extent signature:
[source]
----
span[s:16,a:8,dynamic]<i32[s:4,a:4]>
----

NOTE: Dynamic extent spans include the `,dynamic` marker to indicate runtime-sized views.

=== std::atomic

`std::atomic<T>` types are explicitly specialized to avoid exposing internal implementation details:

[source,cpp]
----
#include <atomic>

std::atomic<int> counter;
----

[source]
----
atomic[s:4,a:4]<i32[s:4,a:4]>
----

=== Smart Pointers

Smart pointers generate specialized signatures:

[cols="1,1,2"]
|===
| Type | Signature Pattern | Notes

| `std::unique_ptr<T>`
| `unique_ptr[s:N,a:N]`
| Size depends on deleter

| `std::shared_ptr<T>`
| `shared_ptr[s:N,a:N]`
| Typically 16 bytes (two pointers)

| `std::weak_ptr<T>`
| `weak_ptr[s:N,a:N]`
| Same as shared_ptr
|===

CAUTION: Smart pointer sizes vary between implementations. Do not use them for binary serialization across different platforms or compilers.

== Signature-Driven Compatibility Model

Boost.TypeLayout uses a **signature-driven compatibility model** for serialization:

[source]
----
Signature Match ⟺ Memory Layout Match ⟺ memcpy Safe
----

=== How It Works

1. Both endpoints generate signatures for the same type
2. If signatures match → types have identical memory layout → memcpy is safe
3. If signatures differ → serialization fails (automatically detected)

This means:

* **Bit-fields are allowed** - signatures include bit positions; layout differences are automatically detected
* **Virtual inheritance is allowed** - signatures include offsets; ABI differences are automatically detected
* **Platform differences are caught** - different compilers produce different signatures for types with platform-specific layouts

=== Runtime State Types (Not Serializable)

Some types have **runtime state** that cannot be safely preserved by memcpy:

[cols="1,2,2"]
|===
| Type | Problem | Solution

| `std::variant<T...>`
| The `_index` field determines which member is active. memcpy cannot preserve object lifetime semantics.
| Use explicit serialization with tagged unions

| `std::optional<T>`
| The `_engaged` flag determines if the value is valid. memcpy after copy may have inconsistent state.
| Serialize presence flag and value separately
|===

Example of why `std::variant` is unsafe:

[source,cpp]
----
std::variant<int, std::string> v1 = 42;      // _index = 0
std::variant<int, std::string> v2 = "hello"; // _index = 1

memcpy(&v2, &v1, sizeof(v1));
// v2._index = 0, but the internal string was not destructed!
// Any subsequent operation on v2 is undefined behavior
----

=== Bit-fields (Allowed)

Bit-fields are **allowed** for serialization because:

1. The signature includes exact bit positions
2. Signature comparison automatically detects cross-compiler differences
3. memcpy of a bit-field struct is semantically correct (just data)

[source,cpp]
----
struct Flags {
    uint32_t version : 4;
    uint32_t flags : 12;
    uint32_t length : 16;
};

// GCC signature:  "struct{version:4@0,flags:12@4,length:16@16}[s:4,a:4]"
// MSVC signature: "struct{version:4@0,flags:12@4,length:16@16}[s:4,a:4]"
// If they match → memcpy safe
// If they differ → serialization fails (detected automatically)
----

TIP: For cross-platform binary protocols, consider using explicit bit manipulation instead of bit-fields for maximum portability.

== Unsupported Types

The following types are currently not supported:

* `void` type (use `void*` for generic pointers)
* Function types (use function pointers instead)
* Incomplete types
* `std::variant<T...>` for serialization (has runtime state)
* `std::optional<T>` for serialization (has runtime state)

== Type Qualifiers

=== const

`const` qualification does not affect layout:

[source,cpp]
----
// Both generate identical signatures
get_layout_signature<int>();
get_layout_signature<const int>();
----

=== volatile

`volatile` types are not supported as they often indicate special memory semantics.

== Empty Types

Empty structs have size 1 (per {cpp} standard):

[source,cpp]
----
struct Empty {};
----

[source]
----
[64-le]struct[s:1,a:1]{}
----

== See Also

* xref:user-guide/layout-signatures.adoc[Layout Signatures] - Signature format details
* xref:user-guide/portability.adoc[Serializability] - Platform-dependent type handling
* xref:user-guide/bitfields.adoc[Bit-fields] - Bit-field support
