[/
    Copyright (c) 2024-2026 TypeLayout Development Team
    
    Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
]

[library Boost.TypeLayout
    [quickbook 1.7]
    [id typelayout]
    [dirname typelayout]
    [copyright 2024-2026 TypeLayout Development Team]
    [purpose Compile-time type layout verification using C++26 static reflection]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
    [authors [XimiCpp]]
    [category Programming Interfaces]
    [category Generic Programming]
]

[def __typelayout__ Boost.TypeLayout]
[def __cpp26__ C++26]
[def __p2996__ P2996]

[section:intro Introduction]

[heading The Problem: Silent Binary Incompatibility]

Binary compatibility bugs are among the most insidious in systems programming. 
Two programs exchange raw bytes through shared memory or network protocols—both 
compile successfully, both pass unit tests, yet one reads garbage from the other.

The culprit: [*invisible differences in struct layout] caused by:

* Compiler variations
* Platform differences  
* Innocent refactoring

[heading A Real-World Example]

``
// The problem: same struct, different layout on Windows vs Linux
struct Record {
    int32_t id;
    long    timestamp;  // 4 bytes on Windows (LLP64), 8 bytes on Linux (LP64)!
    int32_t flags;
};
// Windows: sizeof = 12, offsets: id@0, timestamp@4, flags@8
// Linux:   sizeof = 24, offsets: id@0, timestamp@8, flags@16
// Cross-platform shared memory = silent data corruption!
``

[heading Why Traditional Solutions Fail]

[table Traditional Approaches
    [[Approach] [Problem]]
    [[`static_assert(sizeof(...))`] [Only checks size, not internal layout]]
    [[`#pragma pack`] [Non-portable and error-prone]]
    [[Runtime checks] [Catch bugs too late—after deployment]]
]

[heading The Solution: Compile-Time Layout Contracts]

__typelayout__ leverages __cpp26__ Static Reflection (__p2996__) to generate 
[*complete, semantic layout signatures] at compile time.

``
// Works with struct
struct Player { uint64_t id; char name[32]; float health; };
TYPELAYOUT_BIND(Player, "[64-le]struct[s:48,a:8]{@0[id]:u64[s:8,a:8],...}");

// Works equally well with class (including private members)
class GameEntity {
public:
    GameEntity(uint64_t id) : id_(id), active_(true) {}
private:
    uint64_t id_;     // Private - still reflected!
    bool active_;     // Private - still reflected!
};
TYPELAYOUT_BIND(GameEntity, "[64-le]struct[s:16,a:8]{@0[id_]:u64[s:8,a:8],...}");
``

If the layout ever differs—on any platform, with any compiler—[*compilation fails immediately].

[note TypeLayout is [*NOT] limited to `struct` or POD types. It fully supports 
classes with private members, inheritance, virtual functions, and complex constructors.]

[endsect]

[section:architecture Two-Layer Architecture]

__typelayout__ is organized into two distinct layers:

[heading Layer 1: Core — Layout Signature Engine]

[*Header]: `<boost/typelayout.hpp>`

The foundation of the library. Provides pure memory layout analysis:

* [*Signature Generation]: `get_layout_signature<T>()` produces bit-accurate layout descriptions
* [*Hash Functions]: `get_layout_hash<T>()`, `get_layout_verification<T>()` for efficient comparison
* [*Comparison]: `signatures_match<T, U>()` verifies layout identity between types
* [*Concepts]: `LayoutCompatible`, `LayoutMatch`, `LayoutHashMatch`

[heading Layer 2: Utility — Serialization Safety Analysis]

[*Header]: `<boost/typelayout/typelayout_util.hpp>`

Built on top of the core layer, provides practical serialization utilities:

* [*Platform Sets]: `PlatformSet` defines target architectures
* [*Serialization Checking]: `is_serializable_v<T, P>` validates serialization safety
* [*Concepts]: `Serializable`, `ZeroCopyTransmittable`

[heading Why Two Layers?]

[table Benefits
    [[Benefit] [Description]]
    [[Focused usage] [Use core for ABI verification without serialization overhead]]
    [[Clean dependencies] [Core has no policy dependencies; utility builds on core]]
    [[Extensibility] [Extend utility layer with custom serialization policies]]
]

[endsect]

[section:quickstart Quick Start]

[heading Requirements]

* Compiler: Bloomberg Clang with P2996 support
* Standard: C++26 (`-std=c++26`)
* Flags: `-freflection -freflection-latest`

[heading Installation]

__typelayout__ is header-only. Simply add the `include` directory to your include path.

[heading Basic Usage]

``
#include <boost/typelayout/typelayout.hpp>
using namespace boost::typelayout;

// Define your type
struct Point {
    int32_t x;
    int32_t y;
};

// Get layout signature at compile time
constexpr auto sig = get_layout_signature<Point>();

// Get layout hash for efficient comparison
constexpr auto hash = get_layout_hash<Point>();

// Use static_assert to verify expected layout
static_assert(get_layout_hash<Point>() == 0x1234567890ABCDEF,
              "ABI break detected in Point!");
``

[heading Using the TYPELAYOUT_BIND Macro]

For cross-platform compatibility guarantees:

``
// Bind expected signature - fails compilation if layout differs
TYPELAYOUT_BIND(Point, 
    "[64-le]struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}");
``

[endsect]

[section:signatures Layout Signatures]

[heading Signature Format]

A layout signature is a human-readable string that uniquely identifies a type's 
memory layout:

``
[64-le]struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}
``

[heading Components]

[table Signature Components
    [[Component] [Description] [Example]]
    [[Platform prefix] [Architecture and endianness] [`[64-le]` = 64-bit little-endian]]
    [[Type category] [struct, union, enum, etc.] [`struct[s:8,a:4]`]]
    [[Size/Alignment] [Type size and alignment in bytes] [`s:8,a:4`]]
    [[Field list] [Fields with offset, name, type] [`@0[x]:i32[s:4,a:4]`]]
]

[heading Type Signatures]

[table Fundamental Type Signatures
    [[C++ Type] [Signature]]
    [[`int8_t`, `signed char`] [`i8`]]
    [[`uint8_t`, `unsigned char`] [`u8`]]
    [[`int16_t`, `short`] [`i16`]]
    [[`uint16_t`, `unsigned short`] [`u16`]]
    [[`int32_t`, `int`] [`i32`]]
    [[`uint32_t`, `unsigned int`] [`u32`]]
    [[`int64_t`, `long long`] [`i64`]]
    [[`uint64_t`, `unsigned long long`] [`u64`]]
    [[`float`] [`f32`]]
    [[`double`] [`f64`]]
    [[`bool`] [`bool`]]
    [[`char`] [`char`]]
    [[Pointers] [`ptr`]]
]

[endsect]

[section:reference API Reference]

[heading Core Functions]

[section:get_layout_signature get_layout_signature]

``
template<typename T>
consteval LayoutSignature get_layout_signature();
``

Returns a compile-time layout signature for type `T`.

[*Template Parameters]

* `T` - The type to analyze

[*Returns]

A `LayoutSignature` object containing the type's complete layout information.

[*Example]

``
constexpr auto sig = get_layout_signature<Point>();
static_assert(sig.size > 0);
``

[endsect]

[section:get_layout_hash get_layout_hash]

``
template<typename T>
consteval uint64_t get_layout_hash();
``

Returns a 64-bit FNV-1a hash of the type's layout signature.

[*Template Parameters]

* `T` - The type to analyze

[*Returns]

A 64-bit unsigned integer hash value.

[*Example]

``
constexpr auto hash = get_layout_hash<Point>();
static_assert(hash != 0, "Hash should be non-zero");
``

[endsect]

[section:get_layout_verification get_layout_verification]

``
template<typename T>
consteval LayoutVerification get_layout_verification();
``

Returns a dual-hash verification structure with both FNV-1a and DJB2 hashes.

[*Template Parameters]

* `T` - The type to analyze

[*Returns]

A `LayoutVerification` struct containing:
* `fnv1a` - 64-bit FNV-1a hash
* `djb2` - 64-bit DJB2 hash  
* `length` - Signature length

[*Example]

``
constexpr auto v = get_layout_verification<Point>();
static_assert(v.fnv1a != v.djb2);  // Different hash algorithms
``

[endsect]

[section:signatures_match signatures_match]

``
template<typename T, typename U>
consteval bool signatures_match();
``

Compares layout signatures of two types.

[*Template Parameters]

* `T` - First type to compare
* `U` - Second type to compare

[*Returns]

`true` if both types have identical layout signatures, `false` otherwise.

[*Example]

``
struct A { int x; int y; };
struct B { int a; int b; };

// Same layout, different names
static_assert(!signatures_match<A, B>());  // Names differ!
``

[endsect]

[heading Concepts]

[section:LayoutCompatible LayoutCompatible]

``
template<typename T>
concept LayoutCompatible = /* implementation-defined */;
``

A type satisfies `LayoutCompatible` if its layout can be analyzed by __typelayout__.

[endsect]

[section:LayoutMatch LayoutMatch]

``
template<typename T, typename U>
concept LayoutMatch = signatures_match<T, U>();
``

Two types satisfy `LayoutMatch` if they have identical layout signatures.

[endsect]

[section:LayoutHashMatch LayoutHashMatch]

``
template<typename T, uint64_t ExpectedHash>
concept LayoutHashMatch = (get_layout_hash<T>() == ExpectedHash);
``

A type satisfies `LayoutHashMatch` if its layout hash matches the expected value.

[endsect]

[heading Macros]

[section:TYPELAYOUT_BIND TYPELAYOUT_BIND]

``
#define TYPELAYOUT_BIND(Type, ExpectedSignature)
``

Binds a type to an expected layout signature string. Compilation fails if the 
actual signature differs.

[*Parameters]

* `Type` - The type to verify
* `ExpectedSignature` - Expected signature string literal

[*Example]

``
struct Point { int32_t x; int32_t y; };
TYPELAYOUT_BIND(Point, 
    "[64-le]struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}");
``

[endsect]

[endsect]

[section:rationale Design Rationale]

[heading Why P2996 Static Reflection?]

Before __p2996__, introspecting type layout required:

* Compiler-specific extensions (`__builtin_offset_of`)
* External code generation tools
* Template metaprogramming hacks with limited capabilities

__p2996__ enables:

* True compile-time reflection of any type
* Access to private members (critical for real-world classes)
* Portable, standard-conforming code

[heading Why Compile-Time?]

Runtime layout verification:

* Catches bugs after deployment
* Adds performance overhead
* Cannot prevent binary incompatibility—only detect it

Compile-time verification:

* Catches bugs during development
* Zero runtime cost
* Guarantees binary compatibility

[heading Why Human-Readable Signatures?]

Hash-only approaches:

* Hard to debug when hashes don't match
* No insight into what changed

Human-readable signatures:

* Self-documenting
* Easy to diff and understand changes
* Can be version-controlled

[heading Serializability Design]

The library takes a conservative approach to serializability:

* `wchar_t` - Marked non-serializable (2 vs 4 bytes across platforms)
* `long` - Marked non-serializable (4 vs 8 bytes)
* `long double` - Marked non-serializable (8/12/16 bytes)
* Bit-fields - Marked non-serializable (bit order undefined)
* Pointers - Marked non-serializable (not meaningful cross-process)

[endsect]

[section:history Revision History]

[heading Boost 1.88.0]

* Initial submission to Boost
* Core layout signature functionality
* Serialization utility layer
* Comprehensive test suite

[endsect]

[section:acknowledgements Acknowledgements]

__typelayout__ builds upon:

* The __p2996__ proposal by Wyatt Childers, Andrew Sutton, Faisal Vali, Daveed 
  Vandevoorde, Barry Revzin, and others
* The Bloomberg Clang fork implementing static reflection
* The Boost community for review and feedback

[endsect]
