TypeLayout Comprehensive Signature Audit

Platform: Linux 64-bit

========== Fundamental Integer Types ==========

[PASS] int8_t: [64-le]i8[s:1,a:1]
[PASS] uint8_t: [64-le]u8[s:1,a:1]
[PASS] int16_t: [64-le]i16[s:2,a:2]
[PASS] uint16_t: [64-le]u16[s:2,a:2]
[PASS] int32_t: [64-le]i32[s:4,a:4]
[PASS] uint32_t: [64-le]u32[s:4,a:4]
[PASS] int64_t: [64-le]i64[s:8,a:8]
[PASS] uint64_t: [64-le]u64[s:8,a:8]

========== Fundamental Float Types ==========

[INFO] float sizeof=4 alignof=4 sig=[64-le]f32[s:4,a:4]
[INFO] double sizeof=8 alignof=8 sig=[64-le]f64[s:8,a:8]
[INFO] long double sizeof=16 alignof=16 sig=[64-le]f80[s:16,a:16]

========== Character Types ==========

[PASS] char: [64-le]char[s:1,a:1]
[INFO] wchar_t sizeof=4 alignof=4 sig=[64-le]wchar[s:4,a:4]
[PASS] char8_t: [64-le]char8[s:1,a:1]
[PASS] char16_t: [64-le]char16[s:2,a:2]
[PASS] char32_t: [64-le]char32[s:4,a:4]

========== Boolean and Special Types ==========

[PASS] bool: [64-le]bool[s:1,a:1]
[PASS] std::byte: [64-le]byte[s:1,a:1]
[INFO] std::nullptr_t sizeof=8 alignof=8 sig=[64-le]nullptr[s:8,a:8]

========== Void Type ==========

[INFO] void is an incomplete type - no sizeof/alignof
[INFO] void* sizeof=8 alignof=8 sig=[64-le]ptr[s:8,a:8]
[INFO] void* sig: [64-le]ptr[s:8,a:8]
[INFO] int* sig: [64-le]ptr[s:8,a:8]
[PASS] void pointer type handled correctly

========== Pointer Types ==========

[INFO] int* sizeof=8 alignof=8 sig=[64-le]ptr[s:8,a:8]
[INFO] void* sizeof=8 alignof=8 sig=[64-le]ptr[s:8,a:8]
[INFO] const int* sizeof=8 alignof=8 sig=[64-le]ptr[s:8,a:8]
[INFO] int** sizeof=8 alignof=8 sig=[64-le]ptr[s:8,a:8]
[INFO] const void* const sizeof=8 alignof=8 sig=[64-le]ptr[s:8,a:8]

========== Function Pointer Types ==========

[INFO] FuncPtr1 sizeof=8 alignof=8 sig=[64-le]fnptr[s:8,a:8]
[INFO] FuncPtr2 sizeof=8 alignof=8 sig=[64-le]fnptr[s:8,a:8]
[INFO] FuncPtr3 sizeof=8 alignof=8 sig=[64-le]fnptr[s:8,a:8]
[INFO] FuncPtrNoexcept sizeof=8 alignof=8 sig=[64-le]fnptr[s:8,a:8]

========== Reference Types ==========

[INFO] int& sizeof=4 alignof=4 sig=[64-le]ref[s:8,a:8]
[INFO] int&& sizeof=4 alignof=4 sig=[64-le]rref[s:8,a:8]
[INFO] const int& sizeof=4 alignof=4 sig=[64-le]ref[s:8,a:8]

========== Member Pointer Types ==========

[INFO] DataMemberPtr sizeof=8 alignof=8 sig=[64-le]memptr[s:8,a:8]
[INFO] MethodPtr sizeof=16 alignof=8 sig=[64-le]memptr[s:16,a:8]

========== Array Types ==========

[INFO] int[10] sizeof=40 alignof=4 sig=[64-le]array[s:40,a:4]<i32[s:4,a:4],10>
[INFO] int[3][4] sizeof=48 alignof=4 sig=[64-le]array[s:48,a:4]<array[s:16,a:4]<i32[s:4,a:4],4>,3>
[INFO] char[100] sizeof=100 alignof=1 sig=[64-le]bytes[s:100,a:1]
[INFO] SimplePOD[5] sizeof=40 alignof=4 sig=[64-le]array[s:40,a:4]<struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]},5>

========== CV-Qualified Types ==========

[PASS] CV qualifiers correctly stripped
[INFO] int32_t signature: [64-le]i32[s:4,a:4]

========== User-Defined Structs ==========

[INFO] EmptyStruct sizeof=1 alignof=1 sig=[64-le]struct[s:1,a:1]{}
[INFO] SimplePOD sizeof=8 alignof=4 sig=[64-le]struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}
[INFO] NestedStruct sizeof=12 alignof=4 sig=[64-le]struct[s:12,a:4]{@0[inner]:struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]},@8[z]:i32[s:4,a:4]}
[INFO] WithPointer sizeof=16 alignof=8 sig=[64-le]struct[s:16,a:8]{@0[value]:i32[s:4,a:4],@8[ptr]:ptr[s:8,a:8]}

========== User-Defined Classes (with private members) ==========

[INFO] SimpleClass sizeof=8 alignof=4 sig=[64-le]struct[s:8,a:4]{@0[x_]:i32[s:4,a:4],@4[y_]:i32[s:4,a:4]}
[INFO] NestedClass sizeof=12 alignof=4 sig=[64-le]struct[s:12,a:4]{@0[inner_]:struct[s:8,a:4]{@0[x_]:i32[s:4,a:4],@4[y_]:i32[s:4,a:4]},@8[z_]:i32[s:4,a:4]}
[INFO] SimpleClass with private members: [64-le]struct[s:8,a:4]{@0[x_]:i32[s:4,a:4],@4[y_]:i32[s:4,a:4]}
[PASS] Class types with private members fully supported

========== Inheritance ==========

[INFO] Base sizeof=4 alignof=4 sig=[64-le]struct[s:4,a:4]{@0[base_val_]:i32[s:4,a:4]}
[INFO] DerivedSingle sizeof=8 alignof=4 sig=[64-le]class[s:8,a:4,inherited]{@0[base]:struct[s:4,a:4]{@0[base_val_]:i32[s:4,a:4]},@4[derived_val_]:i32[s:4,a:4]}
[INFO] Base2 sizeof=4 alignof=4 sig=[64-le]struct[s:4,a:4]{@0[base2_val_]:i32[s:4,a:4]}
[INFO] DerivedMultiple sizeof=12 alignof=4 sig=[64-le]class[s:12,a:4,inherited]{@0[base]:struct[s:4,a:4]{@0[base_val_]:i32[s:4,a:4]},@4[base]:struct[s:4,a:4]{@0[base2_val_]:i32[s:4,a:4]},@8[multi_val_]:i32[s:4,a:4]}

--- Virtual Inheritance ---
[INFO] VirtualBase sizeof=4 alignof=4 sig=[64-le]struct[s:4,a:4]{@0[vbase_val_]:i32[s:4,a:4]}
[INFO] DerivedVirtual sizeof=16 alignof=8 sig=[64-le]class[s:16,a:8,inherited]{@12[vbase]:struct[s:4,a:4]{@0[vbase_val_]:i32[s:4,a:4]},@8[vderived_val_]:i32[s:4,a:4]}

========== Polymorphic Classes ==========

[INFO] PolymorphicClass sizeof=16 alignof=8 sig=[64-le]class[s:16,a:8,polymorphic]{@8[poly_val_]:i32[s:4,a:4]}
[INFO] Polymorphic class size includes vtable pointer

========== Unions ==========

[INFO] SimpleUnion sizeof=4 alignof=4 sig=[64-le]union[s:4,a:4]{@0[i]:i32[s:4,a:4],@0[f]:f32[s:4,a:4],@0[c]:bytes[s:4,a:1]}

========== Enum Types ==========

[INFO] CStyleEnum sizeof=4 alignof=4 sig=[64-le]enum[s:4,a:4]<u32[s:4,a:4]>
[INFO] ScopedEnum sizeof=2 alignof=2 sig=[64-le]enum[s:2,a:2]<u16[s:2,a:2]>

========== Bit-fields ==========

[INFO] BitFieldStruct sizeof=4 alignof=4 sig=[64-le]struct[s:4,a:4]{@0.0[a]:bits<4,u32[s:4,a:4]>,@0.4[b]:bits<8,u32[s:4,a:4]>,@1.4[c]:bits<20,u32[s:4,a:4]>}
[INFO] BitFieldStruct signature: [64-le]struct[s:4,a:4]{@0.0[a]:bits<4,u32[s:4,a:4]>,@0.4[b]:bits<8,u32[s:4,a:4]>,@1.4[c]:bits<20,u32[s:4,a:4]>}

========== std::optional ==========

[INFO] std::optional<int> sizeof=8 alignof=4 sig=[64-le]class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:struct[s:8,a:4]{@0[<anon:0>]:union[s:4,a:4]{@0[__null_state_]:char[s:1,a:1],@0[__val_]:i32[s:4,a:4]},@4[__engaged_]:bool[s:1,a:1]}}}}}},@0[base]:struct[s:1,a:1]{},@0[base]:struct[s:1,a:1]{}}
[INFO] std::optional<SimplePOD> sizeof=12 alignof=4 sig=[64-le]class[s:12,a:4,inherited]{@0[base]:class[s:12,a:4,inherited]{@0[base]:class[s:12,a:4,inherited]{@0[base]:class[s:12,a:4,inherited]{@0[base]:class[s:12,a:4,inherited]{@0[base]:class[s:12,a:4,inherited]{@0[base]:struct[s:12,a:4]{@0[<anon:0>]:union[s:8,a:4]{@0[__null_state_]:char[s:1,a:1],@0[__val_]:struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}},@8[__engaged_]:bool[s:1,a:1]}}}}}},@0[base]:struct[s:1,a:1]{},@0[base]:struct[s:1,a:1]{}}
[PASS] std::optional signatures generated correctly

========== std::variant ==========

[INFO] VariantIntFloat sizeof=8 alignof=4 sig=[64-le]class[s:8,a:4,inherited]{@0[base]:struct[s:1,a:1]{},@0[base]:struct[s:1,a:1]{},@0[__impl_]:class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:struct[s:8,a:4]{@0[__data]:union[s:4,a:4]{@0[__dummy]:char[s:1,a:1],@0[__head]:struct[s:4,a:4]{@0[__value]:i32[s:4,a:4]},@0[__tail]:union[s:4,a:4]{@0[__dummy]:char[s:1,a:1],@0[__head]:struct[s:4,a:4]{@0[__value]:f32[s:4,a:4]},@0[__tail]:union[s:1,a:1]{}}},@4[__index]:u32[s:4,a:4]}}}}}}}}}}
[INFO] VariantIntDoubleChar sizeof=16 alignof=8 sig=[64-le]class[s:16,a:8,inherited]{@0[base]:struct[s:1,a:1]{},@0[base]:struct[s:1,a:1]{},@0[__impl_]:class[s:16,a:8,inherited]{@0[base]:class[s:16,a:8,inherited]{@0[base]:class[s:16,a:8,inherited]{@0[base]:class[s:16,a:8,inherited]{@0[base]:class[s:16,a:8,inherited]{@0[base]:class[s:16,a:8,inherited]{@0[base]:class[s:16,a:8,inherited]{@0[base]:class[s:16,a:8,inherited]{@0[base]:struct[s:16,a:8]{@0[__data]:union[s:8,a:8]{@0[__dummy]:char[s:1,a:1],@0[__head]:struct[s:4,a:4]{@0[__value]:i32[s:4,a:4]},@0[__tail]:union[s:8,a:8]{@0[__dummy]:char[s:1,a:1],@0[__head]:struct[s:8,a:8]{@0[__value]:f64[s:8,a:8]},@0[__tail]:union[s:1,a:1]{@0[__dummy]:char[s:1,a:1],@0[__head]:struct[s:1,a:1]{@0[__value]:char[s:1,a:1]},@0[__tail]:union[s:1,a:1]{}}}},@8[__index]:u32[s:4,a:4]}}}}}}}}}}
[PASS] std::variant signatures generated correctly

========== std::tuple ==========

[INFO] TupleInt sizeof=4 alignof=4 sig=[64-le]struct[s:4,a:4]{@0[__base_]:class[s:4,a:4,inherited]{@0[base]:struct[s:4,a:4]{@0[__value_]:i32[s:4,a:4]}}}
[INFO] TupleIntFloat sizeof=8 alignof=4 sig=[64-le]struct[s:8,a:4]{@0[__base_]:class[s:8,a:4,inherited]{@0[base]:struct[s:4,a:4]{@0[__value_]:i32[s:4,a:4]},@4[base]:struct[s:4,a:4]{@0[__value_]:f32[s:4,a:4]}}}
[INFO] TupleIntDoubleChar sizeof=24 alignof=8 sig=[64-le]struct[s:24,a:8]{@0[__base_]:class[s:24,a:8,inherited]{@0[base]:struct[s:4,a:4]{@0[__value_]:i32[s:4,a:4]},@8[base]:struct[s:8,a:8]{@0[__value_]:f64[s:8,a:8]},@16[base]:struct[s:1,a:1]{@0[__value_]:char[s:1,a:1]}}}

========== Edge Cases ==========

--- Anonymous Union ---
[INFO] WithAnonymousUnion sizeof=8 alignof=4 sig=[64-le]struct[s:8,a:4]{@0[header]:i32[s:4,a:4],@4[<anon:1>]:union[s:4,a:4]{@0[as_int]:i32[s:4,a:4],@0[as_float]:f32[s:4,a:4]}}
[PASS] Anonymous union member handled correctly with <anon:N> placeholder

--- [[no_unique_address]] ---
[INFO] NoUniqueAddressTest sizeof=4 alignof=4 sig=[64-le]struct[s:4,a:4]{@0[e1]:struct[s:1,a:1]{},@0[x]:i32[s:4,a:4],@0[e2]:struct[s:1,a:1]{}}
[INFO] Empty1 size: 1
[INFO] NoUniqueAddressTest should be <= sizeof(int32_t) + 2 bytes

--- alignas ---
[INFO] AlignedStruct sizeof=16 alignof=16 sig=[64-le]struct[s:16,a:16]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}

--- __attribute__((packed)) ---
[INFO] PackedStruct sizeof=6 alignof=1 sig=[64-le]struct[s:6,a:1]{@0[a]:char[s:1,a:1],@1[b]:i32[s:4,a:4],@5[c]:char[s:1,a:1]}
[INFO] PackedStruct without packing would be: 8 bytes (with padding)
[INFO] PackedStruct with packing should be: 6 bytes
[PASS] Packed struct correctly removes padding

========== Nested Template Types ==========

[INFO] WrapperInt sizeof=4 alignof=4 sig=[64-le]struct[s:4,a:4]{@0[value]:i32[s:4,a:4]}
[INFO] WrapperSimplePOD sizeof=8 alignof=4 sig=[64-le]struct[s:8,a:4]{@0[value]:struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}}
[INFO] PairIntFloat sizeof=8 alignof=4 sig=[64-le]struct[s:8,a:4]{@0[first]:i32[s:4,a:4],@4[second]:f32[s:4,a:4]}
[INFO] NestedWrapper sizeof=4 alignof=4 sig=[64-le]struct[s:4,a:4]{@0[value]:struct[s:4,a:4]{@0[value]:i32[s:4,a:4]}}
[PASS] Nested template types handled correctly

========== Signature Correctness Verification ==========

[INFO] LayoutA: [64-le]struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}
[INFO] LayoutB: [64-le]struct[s:8,a:4]{@0[a]:i32[s:4,a:4],@4[b]:i32[s:4,a:4]}
[PASS] Different layouts produce different signatures

========== AUDIT COMPLETE ==========

EXIT STATUS: 0
