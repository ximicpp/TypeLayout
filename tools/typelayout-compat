#!/usr/bin/env bash
# typelayout-compat — Cross-Platform Compatibility Toolchain
#
# Automates the two-phase TypeLayout pipeline:
#   Phase 1: Export signatures on each target platform (via Docker or local)
#   Phase 2: Compare signatures at compile time (C++17, no P2996 needed)
#
# Usage:
#   typelayout-compat check   --types my_types.hpp --platforms x86_64-linux-clang,arm64-macos-clang
#   typelayout-compat export  --types my_types.hpp [--output sigs/]
#   typelayout-compat compare --sigs sigs/
#   typelayout-compat list-platforms
#
# Copyright (c) 2024-2026 TypeLayout Development Team
# Distributed under the Boost Software License, Version 1.0.

set -euo pipefail

# =========================================================================
# Resolve paths
# =========================================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TYPELAYOUT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
TYPELAYOUT_INCLUDE="$TYPELAYOUT_ROOT/include"
PLATFORMS_CONF="$SCRIPT_DIR/platforms.conf"
EXPORT_TEMPLATE="$SCRIPT_DIR/sig_export_template.cpp.in"
CHECK_TEMPLATE="$SCRIPT_DIR/compat_check_template.cpp.in"

# =========================================================================
# Colors
# =========================================================================

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# =========================================================================
# Helpers
# =========================================================================

log_info()  { echo -e "${BLUE}[INFO]${NC} $*"; }
log_ok()    { echo -e "${GREEN}[OK]${NC} $*"; }
log_warn()  { echo -e "${YELLOW}[WARN]${NC} $*"; }
log_error() { echo -e "${RED}[ERROR]${NC} $*" >&2; }
log_step()  { echo -e "${CYAN}[STEP]${NC} ${BOLD}$*${NC}"; }

die() { log_error "$@"; exit 1; }

# Parse a field from platforms.conf for a given platform
# Usage: get_platform_field "x86_64-linux-clang" "docker_image"
get_platform_field() {
    local platform="$1" field="$2"
    local in_section=false
    while IFS= read -r line; do
        # Skip comments and empty lines
        [[ "$line" =~ ^[[:space:]]*# ]] && continue
        [[ -z "${line// /}" ]] && continue
        # Section header
        if [[ "$line" =~ ^\[([^\]]+)\] ]]; then
            if [[ "${BASH_REMATCH[1]}" == "$platform" ]]; then
                in_section=true
            else
                $in_section && break
            fi
            continue
        fi
        # Key = Value
        if $in_section && [[ "$line" =~ ^[[:space:]]*${field}[[:space:]]*=[[:space:]]*(.*) ]]; then
            echo "${BASH_REMATCH[1]}" | sed 's/[[:space:]]*$//'
            return 0
        fi
    done < "$PLATFORMS_CONF"
    return 1
}

# List all platform names from platforms.conf
list_all_platforms() {
    grep -v '^\s*#' "$PLATFORMS_CONF" | grep -oP '(?<=\[)[^\]]+(?=\])' 2>/dev/null || true
}

# =========================================================================
# Phase 1: Export signatures
# =========================================================================

# Generate sig_export.cpp from template + user types header
generate_export_source() {
    local types_header="$1"
    local output_cpp="$2"
    local include_dirs="$3"

    # Parse user types header to find struct/class declarations with registrations
    # The user header must contain TYPELAYOUT_REGISTER(TypeName) macros or
    # we auto-detect all struct definitions.
    log_info "Scanning types in: $types_header"

    local registrations=""
    local count=0

    # Auto-detect: look for struct/class definitions (simple heuristic)
    while IFS= read -r line; do
        if [[ "$line" =~ ^[[:space:]]*(struct|class)[[:space:]]+([A-Za-z_][A-Za-z0-9_]*)[[:space:]]*\{ ]]; then
            local typename="${BASH_REMATCH[2]}"
            registrations+="    ex.add<${typename}>(\"${typename}\");"$'\n'
            ((count++))
        fi
    done < "$types_header"

    if [[ $count -eq 0 ]]; then
        die "No struct/class definitions found in $types_header"
    fi

    log_info "Found $count type(s) to export"

    # Determine include path: if types_header is absolute, use it;
    # otherwise make it relative for the #include directive.
    local include_directive
    local basename_header
    basename_header="$(basename "$types_header")"
    include_directive="$basename_header"

    # Generate from template
    sed \
        -e "s|@TYPES_HEADER@|${include_directive}|g" \
        -e "s|@TYPE_REGISTRATIONS@|${registrations}|g" \
        "$EXPORT_TEMPLATE" > "$output_cpp"

    log_ok "Generated export source: $output_cpp"
}

# Export signatures for a single platform
export_platform() {
    local platform="$1"
    local types_header="$2"
    local output_dir="$3"
    local build_dir="$4"
    local include_dirs="$5"

    local mode docker_image compiler flags link_flags env_vars description
    mode=$(get_platform_field "$platform" "mode" 2>/dev/null || echo "docker")
    description=$(get_platform_field "$platform" "description" 2>/dev/null || echo "$platform")

    log_step "Exporting signatures for: $description"

    if [[ "$mode" == "docker" ]]; then
        docker_image=$(get_platform_field "$platform" "docker_image") \
            || die "No docker_image for platform: $platform"
        compiler=$(get_platform_field "$platform" "compiler" 2>/dev/null || echo "clang++")
        flags=$(get_platform_field "$platform" "flags" 2>/dev/null || echo "")
        link_flags=$(get_platform_field "$platform" "link_flags" 2>/dev/null || echo "")
        env_vars=$(get_platform_field "$platform" "env" 2>/dev/null || echo "")

        # Build Docker env args
        local docker_env_args=""
        if [[ -n "$env_vars" ]]; then
            IFS=',' read -ra ENV_PAIRS <<< "$env_vars"
            for pair in "${ENV_PAIRS[@]}"; do
                docker_env_args+=" -e $(echo "$pair" | xargs)"
            done
        fi

        # Prepare build context
        local src_cpp="$build_dir/_sig_export_${platform}.cpp"
        generate_export_source "$types_header" "$src_cpp" "$include_dirs"

        # Get absolute path of types header directory
        local types_dir
        types_dir="$(cd "$(dirname "$types_header")" && pwd)"

        log_info "Building in Docker: $docker_image"

        # Run in Docker: copy sources, compile, run exporter
        docker run --rm \
            -v "$TYPELAYOUT_ROOT:/typelayout:ro" \
            -v "$types_dir:/user_types:ro" \
            -v "$build_dir:/build" \
            -v "$output_dir:/output" \
            -w /tmp/work \
            $docker_env_args \
            "$docker_image" \
            bash -c "
                cp /build/_sig_export_${platform}.cpp .
                cp /user_types/$(basename "$types_header") .
                $compiler $flags -I/typelayout/include -I. \
                    $link_flags \
                    -o sig_export _sig_export_${platform}.cpp && \
                ./sig_export /output/
            " || die "Docker build failed for $platform"

    elif [[ "$mode" == "local" ]]; then
        compiler=$(get_platform_field "$platform" "compiler" 2>/dev/null || echo "clang++")
        flags=$(get_platform_field "$platform" "flags" 2>/dev/null || echo "")
        link_flags=$(get_platform_field "$platform" "link_flags" 2>/dev/null || echo "")
        env_vars=$(get_platform_field "$platform" "env" 2>/dev/null || echo "")

        local src_cpp="$build_dir/_sig_export_${platform}.cpp"
        generate_export_source "$types_header" "$src_cpp" "$include_dirs"

        local types_dir
        types_dir="$(cd "$(dirname "$types_header")" && pwd)"

        log_info "Building locally: $compiler"

        # Set environment
        if [[ -n "$env_vars" ]]; then
            export $env_vars
        fi

        $compiler $flags \
            -I"$TYPELAYOUT_INCLUDE" \
            -I"$types_dir" \
            $link_flags \
            -o "$build_dir/sig_export_${platform}" \
            "$src_cpp" \
            || die "Local build failed for $platform"

        "$build_dir/sig_export_${platform}" "$output_dir/" \
            || die "Export execution failed for $platform"
    else
        die "Unknown mode '$mode' for platform $platform"
    fi

    # Verify output
    local expected_sig
    expected_sig=$(ls "$output_dir/"*.sig.hpp 2>/dev/null | tail -1)
    if [[ -f "$expected_sig" ]]; then
        log_ok "Exported: $(basename "$expected_sig")"
    else
        die "No .sig.hpp generated for $platform"
    fi
}

# =========================================================================
# Phase 2: Compare signatures
# =========================================================================

generate_and_run_checker() {
    local sigs_dir="$1"
    local build_dir="$2"

    log_step "Phase 2: Comparing signatures"

    # Find all .sig.hpp files
    local sig_files=()
    for f in "$sigs_dir"/*.sig.hpp; do
        [[ -f "$f" ]] && sig_files+=("$f")
    done

    if [[ ${#sig_files[@]} -lt 2 ]]; then
        log_warn "Only ${#sig_files[@]} signature file(s) found. Need at least 2 for comparison."
        if [[ ${#sig_files[@]} -eq 1 ]]; then
            log_info "Single platform signatures exported to: ${sig_files[0]}"
        fi
        return 0
    fi

    log_info "Comparing ${#sig_files[@]} platform signatures"

    # Extract namespace names from sig files
    local namespaces=()
    for f in "${sig_files[@]}"; do
        local ns
        ns=$(grep -oP 'namespace\s+\K[a-z0-9_]+(?=\s*\{)' "$f" | tail -1)
        namespaces+=("$ns")
        log_info "  $(basename "$f") → namespace $ns"
    done

    # Generate checker source directly (avoid sed multi-line issues)
    local checker_cpp="$build_dir/_compat_check.cpp"
    {
        echo "// AUTO-GENERATED by typelayout-compat toolchain — do not edit manually."
        echo "// Phase 2: Cross-platform compatibility check."
        echo "// Compiles with C++17 — no P2996 required."
        echo ""

        # Includes
        for f in "${sig_files[@]}"; do
            echo "#include \"$(realpath "$f")\""
        done
        echo ""
        echo "#include <boost/typelayout/tools/compat_check.hpp>"
        echo "#include <iostream>"
        echo ""
        echo "int main() {"
        echo "    using namespace boost::typelayout::compat;"
        echo "    CompatReporter reporter;"
        echo ""

        # Registrations
        for ns in "${namespaces[@]}"; do
            echo "    reporter.add_platform({"
            echo "        boost::typelayout::platform::${ns}::platform_name,"
            echo "        reinterpret_cast<const TypeEntry*>(boost::typelayout::platform::${ns}::types),"
            echo "        boost::typelayout::platform::${ns}::type_count,"
            echo "        boost::typelayout::platform::${ns}::pointer_size,"
            echo "        boost::typelayout::platform::${ns}::sizeof_long,"
            echo "        boost::typelayout::platform::${ns}::sizeof_wchar_t,"
            echo "        boost::typelayout::platform::${ns}::sizeof_long_double,"
            echo "        boost::typelayout::platform::${ns}::max_align,"
            echo "        boost::typelayout::platform::${ns}::arch_prefix"
            echo "    });"
        done
        echo ""
        echo "    reporter.print_report();"
        echo "    return 0;"
        echo "}"
    } > "$checker_cpp"

    # Compile Phase 2 (C++17 only, no P2996)
    local checker_bin="$build_dir/_compat_check"
    local phase2_compiler="c++"

    # Try clang++ first (for libc++ support), then g++
    if command -v clang++ &>/dev/null; then
        phase2_compiler="clang++"
        $phase2_compiler -std=c++17 -stdlib=libc++ \
            -I"$TYPELAYOUT_INCLUDE" \
            -o "$checker_bin" "$checker_cpp" 2>/dev/null \
        || $phase2_compiler -std=c++17 \
            -I"$TYPELAYOUT_INCLUDE" \
            -o "$checker_bin" "$checker_cpp" \
        || die "Phase 2 compilation failed"
    elif command -v g++ &>/dev/null; then
        phase2_compiler="g++"
        $phase2_compiler -std=c++17 \
            -I"$TYPELAYOUT_INCLUDE" \
            -o "$checker_bin" "$checker_cpp" \
            || die "Phase 2 compilation failed"
    else
        die "No C++17 compiler found. Install clang++ or g++."
    fi

    log_ok "Phase 2 compiled with $phase2_compiler"
    echo ""

    # Run report
    "$checker_bin"
}

# =========================================================================
# Commands
# =========================================================================

cmd_check() {
    local types_header="" platforms="" output_dir="" include_dirs=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --types|-t)     types_header="$2"; shift 2 ;;
            --platforms|-p) platforms="$2"; shift 2 ;;
            --output|-o)    output_dir="$2"; shift 2 ;;
            --include|-I)   include_dirs="$2"; shift 2 ;;
            *) die "Unknown option: $1" ;;
        esac
    done

    [[ -z "$types_header" ]] && die "Missing --types <header.hpp>"
    [[ -z "$platforms" ]] && die "Missing --platforms <platform1,platform2,...>"
    [[ -f "$types_header" ]] || die "Types header not found: $types_header"

    # Defaults
    output_dir="${output_dir:-./typelayout-sigs}"
    local build_dir="$output_dir/.build"
    mkdir -p "$output_dir" "$build_dir"

    echo -e "${BOLD}╔══════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BOLD}║  Boost.TypeLayout — Cross-Platform Compatibility Check  ║${NC}"
    echo -e "${BOLD}╚══════════════════════════════════════════════════════════╝${NC}"
    echo ""

    # Phase 1: Export on each platform
    log_step "Phase 1: Exporting signatures"
    IFS=',' read -ra PLATFORM_LIST <<< "$platforms"
    for plat in "${PLATFORM_LIST[@]}"; do
        plat=$(echo "$plat" | xargs)  # trim whitespace
        export_platform "$plat" "$types_header" "$output_dir" "$build_dir" "$include_dirs"
    done
    echo ""

    # Phase 2: Compare
    generate_and_run_checker "$output_dir" "$build_dir"
}

cmd_export() {
    local types_header="" output_dir="" include_dirs=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --types|-t)    types_header="$2"; shift 2 ;;
            --output|-o)   output_dir="$2"; shift 2 ;;
            --include|-I)  include_dirs="$2"; shift 2 ;;
            *) die "Unknown option: $1" ;;
        esac
    done

    [[ -z "$types_header" ]] && die "Missing --types <header.hpp>"
    [[ -f "$types_header" ]] || die "Types header not found: $types_header"

    output_dir="${output_dir:-./typelayout-sigs}"
    local build_dir="$output_dir/.build"
    mkdir -p "$output_dir" "$build_dir"

    log_step "Exporting signatures for current platform"

    local src_cpp="$build_dir/_sig_export_local.cpp"
    generate_export_source "$types_header" "$src_cpp" "$include_dirs"

    local types_dir
    types_dir="$(cd "$(dirname "$types_header")" && pwd)"

    local compiler="clang++"
    local flags="-std=c++26 -freflection -freflection-latest -stdlib=libc++"

    $compiler $flags \
        -I"$TYPELAYOUT_INCLUDE" \
        -I"$types_dir" \
        -o "$build_dir/sig_export_local" \
        "$src_cpp" \
        || die "Compilation failed"

    "$build_dir/sig_export_local" "$output_dir/" || die "Export failed"
    log_ok "Signatures exported to $output_dir/"
}

cmd_compare() {
    local sigs_dir=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --sigs|-s)  sigs_dir="$2"; shift 2 ;;
            *) die "Unknown option: $1" ;;
        esac
    done

    [[ -z "$sigs_dir" ]] && die "Missing --sigs <directory>"
    [[ -d "$sigs_dir" ]] || die "Signatures directory not found: $sigs_dir"

    local build_dir="$sigs_dir/.build"
    mkdir -p "$build_dir"

    echo -e "${BOLD}╔══════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BOLD}║  Boost.TypeLayout — Cross-Platform Compatibility Check  ║${NC}"
    echo -e "${BOLD}╚══════════════════════════════════════════════════════════╝${NC}"
    echo ""

    generate_and_run_checker "$sigs_dir" "$build_dir"
}

cmd_list_platforms() {
    echo -e "${BOLD}Available platforms:${NC}"
    echo ""
    while IFS= read -r plat; do
        local desc mode
        desc=$(get_platform_field "$plat" "description" 2>/dev/null || echo "")
        mode=$(get_platform_field "$plat" "mode" 2>/dev/null || echo "docker")
        printf "  ${CYAN}%-25s${NC} %-40s [%s]\n" "$plat" "$desc" "$mode"
    done < <(list_all_platforms)
    echo ""
    echo "Config: $PLATFORMS_CONF"
}

# =========================================================================
# Usage
# =========================================================================

usage() {
    cat <<EOF
${BOLD}typelayout-compat${NC} — Cross-Platform Compatibility Toolchain

${BOLD}USAGE:${NC}
    typelayout-compat <command> [options]

${BOLD}COMMANDS:${NC}
    check            Full pipeline: export signatures + compare across platforms
    export           Export signatures for current platform only
    compare          Compare existing .sig.hpp files
    list-platforms   Show available target platforms

${BOLD}EXAMPLES:${NC}
    # One-command cross-platform check
    typelayout-compat check \\
        --types include/protocol/types.hpp \\
        --platforms x86_64-linux-clang,arm64-macos-clang

    # Export signatures for current platform
    typelayout-compat export --types my_types.hpp --output sigs/

    # Compare pre-exported signatures
    typelayout-compat compare --sigs sigs/

    # List available platforms
    typelayout-compat list-platforms

${BOLD}OPTIONS:${NC}
    --types, -t      Path to C++ header with type definitions
    --platforms, -p  Comma-separated list of target platforms
    --output, -o     Output directory for .sig.hpp files
    --sigs, -s       Directory containing .sig.hpp files to compare
    --include, -I    Additional include directory

EOF
}

# =========================================================================
# Main
# =========================================================================

main() {
    if [[ $# -eq 0 ]]; then
        usage
        exit 0
    fi

    local cmd="$1"
    shift

    case "$cmd" in
        check)          cmd_check "$@" ;;
        export)         cmd_export "$@" ;;
        compare)        cmd_compare "$@" ;;
        list-platforms) cmd_list_platforms ;;
        -h|--help|help) usage ;;
        *) die "Unknown command: $cmd. Use 'typelayout-compat --help' for usage." ;;
    esac
}

main "$@"
