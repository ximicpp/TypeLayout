#!/usr/bin/env bash
# typelayout-compat — Cross-Platform Compatibility Toolchain
#
# Orchestrates the two-phase TypeLayout pipeline:
#   Phase 1: Compile and run user's export source on each target platform
#   Phase 2: Compile and run user's check source locally
#
# Users write their own .cpp files using declarative macros:
#   Phase 1: TYPELAYOUT_EXPORT_TYPES(Type1, Type2, ...)
#   Phase 2: TYPELAYOUT_CHECK_COMPAT(plat1, plat2, ...)
#
# Usage:
#   typelayout-compat check   --export-source export.cpp --check-source check.cpp --platforms x86_64-linux-clang
#   typelayout-compat export  --source export.cpp [--platform x86_64-linux-clang] [--output sigs/]
#   typelayout-compat compare --source check.cpp
#   typelayout-compat list-platforms
#
# Copyright (c) 2024-2026 TypeLayout Development Team
# Distributed under the Boost Software License, Version 1.0.

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TYPELAYOUT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
TYPELAYOUT_INCLUDE="$TYPELAYOUT_ROOT/include"
PLATFORMS_CONF="$SCRIPT_DIR/platforms.conf"

# Colors
RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m'
BLUE='\033[0;34m'; CYAN='\033[0;36m'; BOLD='\033[1m'; NC='\033[0m'

log_info()  { echo -e "${BLUE}[INFO]${NC} $*"; }
log_ok()    { echo -e "${GREEN}[OK]${NC} $*"; }
log_warn()  { echo -e "${YELLOW}[WARN]${NC} $*"; }
log_error() { echo -e "${RED}[ERROR]${NC} $*" >&2; }
log_step()  { echo -e "${CYAN}[STEP]${NC} ${BOLD}$*${NC}"; }
die() { log_error "$@"; exit 1; }

# Parse a field from platforms.conf
get_platform_field() {
    local platform="$1" field="$2" in_section=false
    while IFS= read -r line; do
        [[ "$line" =~ ^[[:space:]]*# ]] && continue
        [[ -z "${line// /}" ]] && continue
        if [[ "$line" =~ ^\[([^\]]+)\] ]]; then
            [[ "${BASH_REMATCH[1]}" == "$platform" ]] && in_section=true || { $in_section && break; }
            continue
        fi
        if $in_section && [[ "$line" =~ ^[[:space:]]*${field}[[:space:]]*=[[:space:]]*(.*) ]]; then
            echo "${BASH_REMATCH[1]}" | sed 's/[[:space:]]*$//'
            return 0
        fi
    done < "$PLATFORMS_CONF"
    return 1
}

list_all_platforms() {
    grep -v '^\s*#' "$PLATFORMS_CONF" | grep -oP '(?<=\[)[^\]]+(?=\])' 2>/dev/null || true
}

# =========================================================================
# Phase 1: Export — compile user source on target platform
# =========================================================================

export_on_platform() {
    local source="$1" platform="$2" output_dir="$3"
    local mode compiler flags link_flags env_vars docker_image description

    mode=$(get_platform_field "$platform" "mode" 2>/dev/null || echo "docker")
    description=$(get_platform_field "$platform" "description" 2>/dev/null || echo "$platform")
    compiler=$(get_platform_field "$platform" "compiler" 2>/dev/null || echo "clang++")
    flags=$(get_platform_field "$platform" "flags" 2>/dev/null || echo "")
    link_flags=$(get_platform_field "$platform" "link_flags" 2>/dev/null || echo "")
    env_vars=$(get_platform_field "$platform" "env" 2>/dev/null || echo "")

    log_step "Exporting on: $description"

    local source_dir source_name
    source_dir="$(cd "$(dirname "$source")" && pwd)"
    source_name="$(basename "$source")"

    if [[ "$mode" == "docker" ]]; then
        docker_image=$(get_platform_field "$platform" "docker_image") \
            || die "No docker_image for platform: $platform"

        local docker_env_args=""
        if [[ -n "$env_vars" ]]; then
            IFS=',' read -ra pairs <<< "$env_vars"
            for p in "${pairs[@]}"; do docker_env_args+=" -e $(echo "$p" | xargs)"; done
        fi

        docker run --rm \
            -v "$TYPELAYOUT_ROOT:/typelayout:ro" \
            -v "$source_dir:/src:ro" \
            -v "$output_dir:/output" \
            -w /tmp/work \
            $docker_env_args \
            "$docker_image" \
            bash -c "
                cp /src/$source_name .
                $compiler $flags -I/typelayout/include -I/src \
                    $link_flags -o sig_export $source_name && \
                ./sig_export /output/
            " || die "Docker build failed for $platform"

    elif [[ "$mode" == "local" ]]; then
        local build_dir="$output_dir/.build"
        mkdir -p "$build_dir"

        [[ -n "$env_vars" ]] && export $env_vars

        $compiler $flags \
            -I"$TYPELAYOUT_INCLUDE" -I"$source_dir" \
            $link_flags \
            -o "$build_dir/sig_export_${platform}" "$source" \
            || die "Local build failed for $platform"

        "$build_dir/sig_export_${platform}" "$output_dir/" \
            || die "Export failed for $platform"
    else
        die "Unknown mode '$mode' for platform $platform"
    fi

    log_ok "Exported signatures for $platform"
}

# =========================================================================
# Phase 2: Compare — compile user check source locally
# =========================================================================

compile_and_run_check() {
    local source="$1" sigs_dir="$2"

    log_step "Phase 2: Compiling compatibility check"

    local source_dir build_dir checker_bin phase2_compiler
    source_dir="$(cd "$(dirname "$source")" && pwd)"
    build_dir="${sigs_dir}/.build"
    mkdir -p "$build_dir"
    checker_bin="$build_dir/_compat_check"

    if command -v clang++ &>/dev/null; then
        phase2_compiler="clang++"
        $phase2_compiler -std=c++17 -stdlib=libc++ \
            -I"$TYPELAYOUT_INCLUDE" -I"$source_dir" -I"$sigs_dir" \
            -o "$checker_bin" "$source" 2>/dev/null \
        || $phase2_compiler -std=c++17 \
            -I"$TYPELAYOUT_INCLUDE" -I"$source_dir" -I"$sigs_dir" \
            -o "$checker_bin" "$source" \
        || die "Phase 2 compilation failed"
    elif command -v g++ &>/dev/null; then
        phase2_compiler="g++"
        $phase2_compiler -std=c++17 \
            -I"$TYPELAYOUT_INCLUDE" -I"$source_dir" -I"$sigs_dir" \
            -o "$checker_bin" "$source" \
            || die "Phase 2 compilation failed"
    else
        die "No C++17 compiler found."
    fi

    log_ok "Compiled with $phase2_compiler"
    echo ""
    "$checker_bin"
}

# =========================================================================
# Commands
# =========================================================================

cmd_check() {
    local export_source="" check_source="" platforms="" output_dir=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --export-source|-e)  export_source="$2"; shift 2 ;;
            --check-source|-c)   check_source="$2"; shift 2 ;;
            --platforms|-p)      platforms="$2"; shift 2 ;;
            --output|-o)         output_dir="$2"; shift 2 ;;
            *) die "Unknown option: $1" ;;
        esac
    done

    [[ -z "$export_source" ]] && die "Missing --export-source <file.cpp>"
    [[ -z "$check_source" ]]  && die "Missing --check-source <file.cpp>"
    [[ -z "$platforms" ]]     && die "Missing --platforms <platform1,platform2,...>"
    [[ -f "$export_source" ]] || die "Export source not found: $export_source"
    [[ -f "$check_source" ]]  || die "Check source not found: $check_source"

    output_dir="${output_dir:-./typelayout-sigs}"
    mkdir -p "$output_dir"

    echo -e "${BOLD}╔══════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BOLD}║  Boost.TypeLayout — Cross-Platform Compatibility Check  ║${NC}"
    echo -e "${BOLD}╚══════════════════════════════════════════════════════════╝${NC}"
    echo ""

    log_step "Phase 1: Exporting signatures"
    IFS=',' read -ra PLATFORM_LIST <<< "$platforms"
    for plat in "${PLATFORM_LIST[@]}"; do
        plat=$(echo "$plat" | xargs)
        export_on_platform "$export_source" "$plat" "$output_dir"
    done
    echo ""

    compile_and_run_check "$check_source" "$output_dir"
}

cmd_export() {
    local source="" platform="" output_dir=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --source|-s)    source="$2"; shift 2 ;;
            --platform|-p)  platform="$2"; shift 2 ;;
            --output|-o)    output_dir="$2"; shift 2 ;;
            *) die "Unknown option: $1" ;;
        esac
    done

    [[ -z "$source" ]] && die "Missing --source <file.cpp>"
    [[ -f "$source" ]] || die "Source not found: $source"

    output_dir="${output_dir:-./typelayout-sigs}"
    mkdir -p "$output_dir"

    if [[ -n "$platform" ]]; then
        export_on_platform "$source" "$platform" "$output_dir"
    else
        # Local build with default P2996 compiler
        log_step "Exporting signatures (local)"
        local source_dir build_dir
        source_dir="$(cd "$(dirname "$source")" && pwd)"
        build_dir="$output_dir/.build"
        mkdir -p "$build_dir"

        local compiler="clang++"
        local flags="-std=c++26 -freflection -freflection-latest -stdlib=libc++"

        $compiler $flags \
            -I"$TYPELAYOUT_INCLUDE" -I"$source_dir" \
            -o "$build_dir/sig_export_local" "$source" \
            || die "Compilation failed"

        "$build_dir/sig_export_local" "$output_dir/" || die "Export failed"
        log_ok "Signatures exported to $output_dir/"
    fi
}

cmd_compare() {
    local source="" sigs_dir=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --source|-s)  source="$2"; shift 2 ;;
            --sigs)       sigs_dir="$2"; shift 2 ;;
            *) die "Unknown option: $1" ;;
        esac
    done

    [[ -z "$source" ]] && die "Missing --source <file.cpp>"
    [[ -f "$source" ]] || die "Source not found: $source"

    sigs_dir="${sigs_dir:-.}"

    echo -e "${BOLD}╔══════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BOLD}║  Boost.TypeLayout — Cross-Platform Compatibility Check  ║${NC}"
    echo -e "${BOLD}╚══════════════════════════════════════════════════════════╝${NC}"
    echo ""

    compile_and_run_check "$source" "$sigs_dir"
}

cmd_list_platforms() {
    echo -e "${BOLD}Available platforms:${NC}"
    echo ""
    while IFS= read -r plat; do
        local desc mode
        desc=$(get_platform_field "$plat" "description" 2>/dev/null || echo "")
        mode=$(get_platform_field "$plat" "mode" 2>/dev/null || echo "docker")
        printf "  ${CYAN}%-25s${NC} %-40s [%s]\n" "$plat" "$desc" "$mode"
    done < <(list_all_platforms)
    echo ""
    echo "Config: $PLATFORMS_CONF"
}

usage() {
    cat <<EOF
${BOLD}typelayout-compat${NC} — Cross-Platform Compatibility Toolchain

${BOLD}USAGE:${NC}
    typelayout-compat <command> [options]

${BOLD}COMMANDS:${NC}
    check            Full pipeline: export on each platform + compare
    export           Export signatures (current platform or via Docker)
    compare          Compile and run a check source file
    list-platforms   Show available target platforms

${BOLD}EXAMPLES:${NC}
    # Full pipeline
    typelayout-compat check \\
        --export-source export_types.cpp \\
        --check-source  check_compat.cpp \\
        --platforms x86_64-linux-clang,arm64-linux-clang

    # Export on a specific platform
    typelayout-compat export --source export_types.cpp --platform x86_64-linux-clang

    # Export on current platform (local P2996 Clang)
    typelayout-compat export --source export_types.cpp --output sigs/

    # Run a check source file
    typelayout-compat compare --source check_compat.cpp --sigs sigs/

${BOLD}OPTIONS:${NC}
    --export-source, -e   Phase 1 source (uses TYPELAYOUT_EXPORT_TYPES macro)
    --check-source, -c    Phase 2 source (uses TYPELAYOUT_CHECK_COMPAT macro)
    --source, -s           Source file for export/compare commands
    --platforms, -p        Comma-separated platform list
    --platform             Single platform for export
    --output, -o           Output directory for .sig.hpp files
    --sigs                 Directory containing .sig.hpp for compare

EOF
}

main() {
    [[ $# -eq 0 ]] && { usage; exit 0; }

    local cmd="$1"; shift
    case "$cmd" in
        check)          cmd_check "$@" ;;
        export)         cmd_export "$@" ;;
        compare)        cmd_compare "$@" ;;
        list-platforms) cmd_list_platforms ;;
        -h|--help|help) usage ;;
        *) die "Unknown command: $cmd" ;;
    esac
}

main "$@"