// Boost.TypeLayout
//
// Signature Comparison Tool
//
// This tool compares type layout signatures across multiple platforms.
// It reads signature files generated by siggen and reports compatibility.
//
// Usage:
//   g++ -std=c++17 compare_signatures.cpp -o compare
//   ./compare sig_linux.txt sig_windows.txt [sig_macos.txt ...]
//
// Exit codes:
//   0 - All types are compatible
//   1 - Some types are incompatible
//   2 - Error (invalid input, etc.)
//
// Copyright (c) 2024-2026 TypeLayout Development Team
// Distributed under the Boost Software License, Version 1.0.

#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <map>
#include <set>
#include <cstdint>
#include <cstdlib>
#include <algorithm>
#include <iomanip>

// =========================================================================
// Data Structures
// =========================================================================

struct TypeSignature {
    std::string name;
    uint64_t hash;
    size_t size;
    size_t align;
};

struct PlatformSignatures {
    std::string filename;
    std::string platform;     // e.g., "linux-x64"
    std::string arch_prefix;  // e.g., "[64-le]"
    std::vector<TypeSignature> types;
};

// =========================================================================
// Signature File Parser
// =========================================================================

bool load_signatures(const std::string& filename, PlatformSignatures& out) {
    std::ifstream file(filename);
    if (!file) {
        std::cerr << "Error: Cannot open file: " << filename << "\n";
        return false;
    }
    
    out.filename = filename;
    std::string line;
    
    while (std::getline(file, line)) {
        if (line.empty()) continue;
        
        std::istringstream iss(line);
        std::string first_token;
        iss >> first_token;
        
        if (first_token == "__PLATFORM__") {
            iss >> out.platform;
        } else if (first_token == "__ARCH__") {
            iss >> out.arch_prefix;
        } else {
            // Type signature line: TypeName Hash Size Align
            TypeSignature sig;
            sig.name = first_token;
            iss >> sig.hash >> sig.size >> sig.align;
            out.types.push_back(sig);
        }
    }
    
    if (out.platform.empty()) {
        std::cerr << "Warning: No __PLATFORM__ found in " << filename << "\n";
        // Use filename as platform name
        out.platform = filename;
    }
    
    return true;
}

// =========================================================================
// Comparison Logic
// =========================================================================

struct ComparisonResult {
    std::vector<std::string> compatible_types;
    
    struct IncompatibleType {
        std::string name;
        std::map<std::string, TypeSignature> platform_sigs;  // platform -> signature
    };
    std::vector<IncompatibleType> incompatible_types;
    
    std::vector<std::string> missing_types;  // Types not present on all platforms
};

ComparisonResult compare_signatures(const std::vector<PlatformSignatures>& all_sigs) {
    ComparisonResult result;
    
    // Build type -> platform -> signature mapping
    std::map<std::string, std::map<std::string, TypeSignature>> type_map;
    std::set<std::string> all_types;
    
    for (const auto& platform_sig : all_sigs) {
        for (const auto& type_sig : platform_sig.types) {
            type_map[type_sig.name][platform_sig.platform] = type_sig;
            all_types.insert(type_sig.name);
        }
    }
    
    // Check each type across all platforms
    for (const auto& type_name : all_types) {
        const auto& platform_map = type_map[type_name];
        
        // Check if type exists on all platforms
        if (platform_map.size() != all_sigs.size()) {
            result.missing_types.push_back(type_name);
            continue;
        }
        
        // Check if all hashes match
        uint64_t first_hash = 0;
        bool first = true;
        bool compatible = true;
        
        for (const auto& [platform, sig] : platform_map) {
            if (first) {
                first_hash = sig.hash;
                first = false;
            } else if (sig.hash != first_hash) {
                compatible = false;
                break;
            }
        }
        
        if (compatible) {
            result.compatible_types.push_back(type_name);
        } else {
            ComparisonResult::IncompatibleType incompat;
            incompat.name = type_name;
            incompat.platform_sigs = platform_map;
            result.incompatible_types.push_back(incompat);
        }
    }
    
    // Sort for consistent output
    std::sort(result.compatible_types.begin(), result.compatible_types.end());
    std::sort(result.incompatible_types.begin(), result.incompatible_types.end(),
        [](const auto& a, const auto& b) { return a.name < b.name; });
    std::sort(result.missing_types.begin(), result.missing_types.end());
    
    return result;
}

// =========================================================================
// Report Generation
// =========================================================================

void print_report(const std::vector<PlatformSignatures>& all_sigs,
                  const ComparisonResult& result) {
    std::cout << "\n";
    std::cout << "╔══════════════════════════════════════════════════════════════╗\n";
    std::cout << "║     TypeLayout Cross-Platform Compatibility Report          ║\n";
    std::cout << "╚══════════════════════════════════════════════════════════════╝\n";
    std::cout << "\n";
    
    // List platforms
    std::cout << "Platforms analyzed:\n";
    for (const auto& sig : all_sigs) {
        std::cout << "  • " << sig.platform << " " << sig.arch_prefix
                  << " (" << sig.filename << ")\n";
    }
    std::cout << "\n";
    
    // Summary
    size_t total = result.compatible_types.size() + 
                   result.incompatible_types.size() +
                   result.missing_types.size();
    
    std::cout << "Summary:\n";
    std::cout << "  Total types:        " << total << "\n";
    std::cout << "  Compatible:         " << result.compatible_types.size() << "\n";
    std::cout << "  Incompatible:       " << result.incompatible_types.size() << "\n";
    if (!result.missing_types.empty()) {
        std::cout << "  Missing on some:    " << result.missing_types.size() << "\n";
    }
    std::cout << "\n";
    
    // Compatible types
    if (!result.compatible_types.empty()) {
        std::cout << "✅ COMPATIBLE TYPES:\n";
        for (const auto& name : result.compatible_types) {
            std::cout << "   " << name << "\n";
        }
        std::cout << "\n";
    }
    
    // Incompatible types (detailed)
    if (!result.incompatible_types.empty()) {
        std::cout << "❌ INCOMPATIBLE TYPES:\n\n";
        
        for (const auto& incompat : result.incompatible_types) {
            std::cout << "   " << incompat.name << ":\n";
            std::cout << "   ┌─────────────────┬────────────────────┬──────┬───────┐\n";
            std::cout << "   │ Platform        │ Hash               │ Size │ Align │\n";
            std::cout << "   ├─────────────────┼────────────────────┼──────┼───────┤\n";
            
            for (const auto& [platform, sig] : incompat.platform_sigs) {
                std::cout << "   │ " << std::left << std::setw(15) << platform
                          << " │ 0x" << std::hex << std::setw(16) << std::setfill('0') << sig.hash
                          << std::dec << std::setfill(' ')
                          << " │ " << std::setw(4) << sig.size
                          << " │ " << std::setw(5) << sig.align << " │\n";
            }
            
            std::cout << "   └─────────────────┴────────────────────┴──────┴───────┘\n";
            std::cout << "\n";
        }
    }
    
    // Missing types
    if (!result.missing_types.empty()) {
        std::cout << "⚠️  TYPES MISSING ON SOME PLATFORMS:\n";
        for (const auto& name : result.missing_types) {
            std::cout << "   " << name << "\n";
        }
        std::cout << "\n";
    }
    
    // Final verdict
    std::cout << "────────────────────────────────────────────────────────────────\n";
    if (result.incompatible_types.empty() && result.missing_types.empty()) {
        std::cout << "✅ PASS: All " << result.compatible_types.size() 
                  << " types are compatible across all platforms.\n";
    } else {
        std::cout << "❌ FAIL: " << result.incompatible_types.size()
                  << " type(s) are incompatible across platforms.\n";
    }
    std::cout << "\n";
}

// =========================================================================
// Main
// =========================================================================

void print_usage(const char* program) {
    std::cerr << "Usage: " << program << " <sig1.txt> <sig2.txt> [sig3.txt ...]\n";
    std::cerr << "\n";
    std::cerr << "Compare type layout signatures across multiple platforms.\n";
    std::cerr << "\n";
    std::cerr << "Arguments:\n";
    std::cerr << "  sig*.txt    Signature files generated by siggen tool\n";
    std::cerr << "\n";
    std::cerr << "Exit codes:\n";
    std::cerr << "  0  All types are compatible\n";
    std::cerr << "  1  Some types are incompatible\n";
    std::cerr << "  2  Error (invalid input, etc.)\n";
}

int main(int argc, char* argv[]) {
    if (argc < 3) {
        print_usage(argv[0]);
        return 2;
    }
    
    // Load all signature files
    std::vector<PlatformSignatures> all_sigs;
    
    for (int i = 1; i < argc; ++i) {
        PlatformSignatures sig;
        if (!load_signatures(argv[i], sig)) {
            return 2;
        }
        all_sigs.push_back(sig);
    }
    
    // Compare signatures
    ComparisonResult result = compare_signatures(all_sigs);
    
    // Print report
    print_report(all_sigs, result);
    
    // Return appropriate exit code
    if (!result.incompatible_types.empty()) {
        return 1;
    }
    
    return 0;
}
