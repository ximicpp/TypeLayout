# §5 Cross-Platform Verification Toolchain

A practical type layout verification system must handle the reality of
cross-platform development: the same source code compiled on Linux x86_64,
macOS ARM64, and Windows x64 may produce different layouts. TypeLayout
addresses this through a *two-phase architecture* that decouples signature
generation from signature comparison.

## 5.1 The Two-Phase Architecture

```
Phase 1: Signature Export (requires P2996)
┌──────────────────┐    ┌──────────────────┐    ┌──────────────────┐
│ Linux x86_64     │    │ macOS ARM64      │    │ Windows x64      │
│ P2996 Compiler   │    │ P2996 Compiler   │    │ P2996 Compiler   │
│                  │    │                  │    │                  │
│ SigExporter<T>   │    │ SigExporter<T>   │    │ SigExporter<T>   │
│   → .sig.hpp     │    │   → .sig.hpp     │    │   → .sig.hpp     │
└──────────────────┘    └──────────────────┘    └──────────────────┘
        │                       │                       │
        └───────────────────────┼───────────────────────┘
                                │
                         Phase 2: Comparison
                    ┌───────────────────────┐
                    │ Any C++17 Compiler     │
                    │ (no P2996 needed)      │
                    │                        │
                    │ TYPELAYOUT_CHECK_COMPAT│
                    │   → match / differ     │
                    │   + safety level       │
                    └───────────────────────┘
```

**Phase 1** runs on each target platform using a P2996-capable compiler.
It generates `.sig.hpp` files—self-contained C++ headers that embed
signature strings as `constexpr` variables. This phase is performed once
per platform per type, typically in CI.

**Phase 2** runs on *any* platform using *any* C++17 compiler. It includes
the `.sig.hpp` files from multiple platforms and performs string comparison
at compile time. No reflection is needed—the signatures are already
materialized as string literals.

## 5.2 The .sig.hpp Format

Each `.sig.hpp` file contains:

```cpp
// Auto-generated by TypeLayout SigExporter
// Platform: x86_64-linux-clang
// Type: PacketHeader

#pragma once

namespace typelayout_sigs {
namespace x86_64_linux_clang {

constexpr auto PacketHeader_layout =
    "[64-le]record[s:24,a:8]{@0:u32[s:4,a:4],@4:u32[s:4,a:4],"
    "@8:u32[s:4,a:4],@12:u32[s:4,a:4],@16:u64[s:8,a:8]}";

constexpr auto PacketHeader_definition =
    "[64-le]record[s:24,a:8]{@0[magic]:u32[s:4,a:4],"
    "@4[version]:u32[s:4,a:4],@8[flags]:u32[s:4,a:4],"
    "@12[length]:u32[s:4,a:4],@16[timestamp]:u64[s:8,a:8]}";

} // namespace x86_64_linux_clang
} // namespace typelayout_sigs
```

Key properties of the format:
- **Self-contained**: No dependencies beyond standard C++17
- **Human-readable**: Signatures are visible in the file for manual inspection
- **Constexpr**: All values are compile-time constants
- **Namespaced**: Platform identifier prevents collisions

## 5.3 The SigExporter API

Phase 1 uses `SigExporter` to generate signature files:

```cpp
#include <boost/typelayout/tools/sig_export.hpp>

using namespace boost::typelayout;

// Export signatures for a type
SigExporter::export_type<PacketHeader>("PacketHeader");

// Multiple types in one file
SigExporter::begin("my_types");
SigExporter::export_type<PacketHeader>("PacketHeader");
SigExporter::export_type<ConfigBlock>("ConfigBlock");
SigExporter::end();
```

The exporter automatically detects the platform (architecture, OS, compiler)
via compile-time macros and encodes it in the namespace.

## 5.4 The Compatibility Checker API

Phase 2 uses `compat_check.hpp` to compare signatures across platforms:

```cpp
#include <boost/typelayout/tools/compat_check.hpp>

// Include signatures from multiple platforms
#include "sigs/x86_64_linux_clang.sig.hpp"
#include "sigs/x86_64_windows_msvc.sig.hpp"

// Compare at compile time
constexpr auto result = check_compat(
    x86_64_linux_clang::PacketHeader_layout,
    x86_64_windows_msvc::PacketHeader_layout
);

static_assert(result == CompatResult::Match,
    "PacketHeader layout differs between Linux and Windows!");
```

The checker also provides a runtime report function for CI integration
that outputs a human-readable compatibility matrix.

## 5.5 CI/CD Integration

The two-phase architecture integrates naturally into CI/CD pipelines:

1. **Build stage**: Each platform job exports `.sig.hpp` files as build
   artifacts
2. **Verify stage**: A platform-independent job collects all `.sig.hpp`
   files and runs the compatibility checker
3. **Gate**: The pipeline fails if any type's layout differs unexpectedly
   across platforms

This workflow provides *continuous cross-platform ABI monitoring* with
no manual effort beyond the initial setup.

## 5.6 Design Rationale

The two-phase split serves two purposes:

1. **Practical**: P2996 is currently available only in Bloomberg's Clang
   fork. By materializing signatures as string literals, Phase 2 can run
   on any compiler—including MSVC, GCC, and standard Clang.

2. **Conceptual**: Signature *generation* is a reflection operation (it
   needs to inspect type structure). Signature *comparison* is a string
   operation (it only needs to compare two strings). Separating these
   concerns is natural and reduces the dependency surface.

When P2996 becomes widely available (post-C++26 standardization), both
phases can be combined into a single compilation for *same-platform*
verification. Cross-platform comparison inherently requires separate
compilations (one per platform), so the two-phase architecture remains
essential for that use case.
