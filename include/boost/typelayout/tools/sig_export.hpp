// Signature Export Tool — generates .sig.hpp headers for cross-platform comparison.
//
// Phase 1 of the two-phase cross-platform compatibility pipeline.
// Compile and run this on each target platform to produce a header file
// containing constexpr signature strings that can be compared at compile time
// on any C++17 compiler (P2996 is NOT required for Phase 2).
//
// Copyright (c) 2024-2026 TypeLayout Development Team
// Distributed under the Boost Software License, Version 1.0.

#ifndef BOOST_TYPELAYOUT_TOOLS_SIG_EXPORT_HPP
#define BOOST_TYPELAYOUT_TOOLS_SIG_EXPORT_HPP

#include <boost/typelayout/typelayout.hpp>
#include <boost/typelayout/tools/platform_detect.hpp>

#include <string>
#include <vector>
#include <fstream>
#include <iostream>
#include <chrono>
#include <ctime>
#include <algorithm>

namespace boost {
namespace typelayout {

/// Entry stored by SigExporter for each registered type.
struct ExportEntry {
    std::string name;
    std::string layout_sig;
    std::string definition_sig;
};

/// Signature exporter — collects type signatures and writes a .sig.hpp header.
///
/// Usage:
///   SigExporter ex;                       // auto-detect platform
///   SigExporter ex("custom_platform");    // manual override
///   ex.add<MyType>("MyType");
///   ex.write("sigs/x86_64_linux_clang.sig.hpp");
class SigExporter {
public:
    /// Construct with auto-detected platform name.
    SigExporter()
        : platform_name_(platform::get_platform_name())
        , display_name_(platform::get_platform_display_name())
    {}

    /// Construct with a manual platform name override.
    explicit SigExporter(const std::string& platform_name)
        : platform_name_(platform_name)
        , display_name_(platform_name)
    {}

    /// Register a type for export. The name must be a valid C++ identifier.
    template <typename T>
    void add(const std::string& name) {
        constexpr auto layout = get_layout_signature<T>();
        constexpr auto defn   = get_definition_signature<T>();

        entries_.push_back({
            name,
            std::string(layout.value, layout.length()),
            std::string(defn.value, defn.length())
        });
    }

    /// Get the platform name (for constructing output paths).
    const std::string& platform_name() const { return platform_name_; }

    /// Get the display name.
    const std::string& display_name() const { return display_name_; }

    /// Get registered entries.
    const std::vector<ExportEntry>& entries() const { return entries_; }

    /// Write the .sig.hpp header file. Returns 0 on success, 1 on failure.
    int write(const std::string& path) const {
        std::ofstream out(path);
        if (!out.is_open()) {
            std::cerr << "Error: cannot open " << path << " for writing\n";
            return 1;
        }

        write_header(out);
        write_platform_metadata(out);
        write_type_signatures(out);
        write_type_registry(out);
        write_footer(out);

        out.close();
        std::cout << "Exported " << entries_.size() << " type(s) to " << path
                  << " [" << platform_name_ << "]\n";
        return 0;
    }

    /// Write to stdout (for piping or debugging).
    void write_stdout() const {
        write_header(std::cout);
        write_platform_metadata(std::cout);
        write_type_signatures(std::cout);
        write_type_registry(std::cout);
        write_footer(std::cout);
    }

private:
    std::string platform_name_;
    std::string display_name_;
    std::vector<ExportEntry> entries_;

    /// Escape a string for use inside a C string literal.
    static std::string escape(const std::string& s) {
        std::string result;
        result.reserve(s.size() + 8);
        for (char c : s) {
            if (c == '\\')     result += "\\\\";
            else if (c == '"') result += "\\\"";
            else if (c == '\n') result += "\\n";
            else               result += c;
        }
        return result;
    }

    /// Generate an include guard token from the platform name.
    std::string include_guard() const {
        std::string guard = "BOOST_TYPELAYOUT_SIG_" + platform_name_;
        std::transform(guard.begin(), guard.end(), guard.begin(),
            [](unsigned char c) { return std::toupper(c); });
        guard += "_HPP";
        return guard;
    }

    /// Get current timestamp as ISO 8601 string.
    static std::string timestamp() {
        auto now = std::chrono::system_clock::now();
        auto time = std::chrono::system_clock::to_time_t(now);
        char buf[32];
        std::strftime(buf, sizeof(buf), "%Y-%m-%dT%H:%M:%SZ", std::gmtime(&time));
        return buf;
    }

    void write_header(std::ostream& os) const {
        std::string guard = include_guard();
        os << "// AUTO-GENERATED by Boost.TypeLayout Signature Export Tool\n";
        os << "// Platform: " << platform_name_ << " (" << display_name_ << ")\n";
        os << "// Generated: " << timestamp() << "\n";
        os << "//\n";
        os << "// This file contains constexpr signature data and can be compiled\n";
        os << "// by any C++17 or later compiler. P2996 is NOT required.\n";
        os << "\n";
        os << "#ifndef " << guard << "\n";
        os << "#define " << guard << "\n";
        os << "\n";
        os << "#include <cstddef>\n";
        os << "\n";
        os << "namespace boost { namespace typelayout { namespace platform {\n";
        os << "namespace " << platform_name_ << " {\n";
        os << "\n";
    }

    void write_platform_metadata(std::ostream& os) const {
        constexpr auto arch = get_arch_prefix();

        os << "// ---- Platform Metadata ----\n";
        os << "\n";
        os << "inline constexpr const char platform_name[] = \""
           << escape(platform_name_) << "\";\n";
        os << "inline constexpr const char arch_prefix[] = \""
           << std::string(arch.value, arch.length()) << "\";\n";
        os << "inline constexpr std::size_t pointer_size      = "
           << sizeof(void*) << ";\n";
        os << "inline constexpr std::size_t sizeof_long        = "
           << sizeof(long) << ";\n";
        os << "inline constexpr std::size_t sizeof_wchar_t     = "
           << sizeof(wchar_t) << ";\n";
        os << "inline constexpr std::size_t sizeof_long_double = "
           << sizeof(long double) << ";\n";
        os << "inline constexpr std::size_t max_align          = "
           << alignof(std::max_align_t) << ";\n";
        os << "\n";
    }

    void write_type_signatures(std::ostream& os) const {
        os << "// ---- Type Signatures ----\n";
        os << "\n";

        for (const auto& e : entries_) {
            os << "// --- " << e.name << " ---\n";
            os << "inline constexpr const char " << e.name << "_layout[] =\n";
            os << "    \"" << escape(e.layout_sig) << "\";\n";
            os << "inline constexpr const char " << e.name << "_definition[] =\n";
            os << "    \"" << escape(e.definition_sig) << "\";\n";
            os << "\n";
        }
    }

    void write_type_registry(std::ostream& os) const {
        os << "// ---- Type Registry (for runtime iteration) ----\n";
        os << "\n";
        os << "struct TypeEntry {\n";
        os << "    const char* name;\n";
        os << "    const char* layout_sig;\n";
        os << "    const char* definition_sig;\n";
        os << "};\n";
        os << "\n";
        os << "inline constexpr TypeEntry types[] = {\n";
        for (const auto& e : entries_) {
            os << "    {\"" << escape(e.name) << "\", "
               << e.name << "_layout, "
               << e.name << "_definition},\n";
        }
        os << "};\n";
        os << "\n";
        os << "inline constexpr int type_count = "
           << entries_.size() << ";\n";
        os << "\n";
    }

    void write_footer(std::ostream& os) const {
        std::string guard = include_guard();
        os << "}}}} // namespace boost::typelayout::platform::" << platform_name_ << "\n";
        os << "\n";
        os << "#endif // " << guard << "\n";
    }
};

} // namespace typelayout
} // namespace boost

#endif // BOOST_TYPELAYOUT_TOOLS_SIG_EXPORT_HPP
