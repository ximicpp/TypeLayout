Start testing: Feb 05 17:31 UTC
----------------------------------------------------------
1/6 Testing: test_all_types
1/6 Test: test_all_types
Command: "/workspace/build-linux/test_all_types"
Directory: /workspace/build-linux
"test_all_types" start time: Feb 05 17:31 UTC
Output:
----------------------------------------------------------
<end of output>
Test time =   0.01 sec
----------------------------------------------------------
Test Passed.
"test_all_types" end time: Feb 05 17:31 UTC
"test_all_types" time elapsed: 00:00:00
----------------------------------------------------------

2/6 Testing: test_signature_extended
2/6 Test: test_signature_extended
Command: "/workspace/build-linux/test_signature_extended"
Directory: /workspace/build-linux
"test_signature_extended" start time: Feb 05 17:31 UTC
Output:
----------------------------------------------------------
===================================================
TypeLayout Extended Signature Tests
===================================================

=== std::array Tests ===
std::array<int, 4>: [64-le]struct[s:16,a:4]{@0[__elems_]:array[s:16,a:4]<i32[s:4,a:4],4>}
  sizeof: 16, alignof: 4
std::array<double, 2>: [64-le]struct[s:16,a:8]{@0[__elems_]:array[s:16,a:8]<f64[s:8,a:8],2>}
  sizeof: 16, alignof: 8
std::array<int, 0>: [64-le]struct[s:4,a:4]{@0[__elems_]:array[s:4,a:1]<struct[s:1,a:1]{},4>}
  sizeof: 4, alignof: 4

=== std::pair Tests ===
std::pair<int, double>: [64-le]struct[s:16,a:8]{@0[first]:i32[s:4,a:4],@8[second]:f64[s:8,a:8]}
  sizeof: 16, alignof: 8
std::pair<char, char>: [64-le]struct[s:2,a:1]{@0[first]:char[s:1,a:1],@1[second]:char[s:1,a:1]}
  sizeof: 2, alignof: 1
std::pair<std::pair<int, int>, double>: [64-le]struct[s:16,a:8]{@0[first]:struct[s:8,a:4]{@0[first]:i32[s:4,a:4],@4[second]:i32[s:4,a:4]},@8[second]:f64[s:8,a:8]}
  sizeof: 16, alignof: 8

=== Diamond Inheritance Tests ===
DiamondDerived: [64-le]class[s:40,a:8,inherited]{@0[base]:class[s:16,a:8,inherited]{@12[vbase]:struct[s:4,a:4]{@0[base_val]:i32[s:4,a:4]},@8[left_val]:i32[s:4,a:4]},@16[base]:class[s:16,a:8,inherited]{@12[vbase]:struct[s:4,a:4]{@0[base_val]:i32[s:4,a:4]},@8[right_val]:i32[s:4,a:4]},@28[derived_val]:i32[s:4,a:4]}
  sizeof: 40, alignof: 8

=== Mutable Member Tests ===
MutableTest: [64-le]struct[s:12,a:4]{@0[normal_val]:i32[s:4,a:4],@4[mutable_val]:i32[s:4,a:4],@8[const_val]:i32[s:4,a:4]}
  sizeof: 12, alignof: 4

=== Cross-Boundary Bit-field Tests ===
CrossBoundaryBitfield: [64-le]struct[s:8,a:4]{@0.0[a]:bits<20,u32[s:4,a:4]>,@4.0[b]:bits<20,u32[s:4,a:4]>,@6.4[c]:bits<8,u32[s:4,a:4]>}
  sizeof: 8, alignof: 4

=== Recursive Type Tests ===
RecursiveNode: [64-le]struct[s:24,a:8]{@0[value]:i32[s:4,a:4],@8[next]:ptr[s:8,a:8],@16[prev]:ptr[s:8,a:8]}
  sizeof: 24, alignof: 8

=== Lambda Type Tests ===
Stateless lambda: [64-le]struct[s:1,a:1]{}
  sizeof: 1, alignof: 1
Capturing lambda [int, double]: [64-le]struct[s:16,a:8]{@0[<anon:0>]:i32[s:4,a:4],@8[<anon:1>]:f64[s:8,a:8]}
  sizeof: 16, alignof: 8

=== std::complex Tests ===
std::complex<float>: [64-le]struct[s:8,a:4]{@0[__re_]:f32[s:4,a:4],@4[__im_]:f32[s:4,a:4]}
  sizeof: 8, alignof: 4
std::complex<double>: [64-le]struct[s:16,a:8]{@0[__re_]:f64[s:8,a:8],@8[__im_]:f64[s:8,a:8]}
  sizeof: 16, alignof: 8

=== std::string_view / std::span Tests ===
std::string_view: [64-le]struct[s:16,a:8]{@0[__data_]:ptr[s:8,a:8],@8[__size_]:u64[s:8,a:8]}
  sizeof: 16, alignof: 8
std::span<int>: [64-le]struct[s:16,a:8]{@0[__data_]:ptr[s:8,a:8],@8[__size_]:u64[s:8,a:8]}
  sizeof: 16, alignof: 8
std::span<int, 4>: [64-le]struct[s:8,a:8]{@0[__data_]:ptr[s:8,a:8]}
  sizeof: 8, alignof: 8

===================================================
All extended tests completed!
===================================================
<end of output>
Test time =   0.01 sec
----------------------------------------------------------
Test Passed.
"test_signature_extended" end time: Feb 05 17:31 UTC
"test_signature_extended" time elapsed: 00:00:00
----------------------------------------------------------

3/6 Testing: test_signature_comprehensive
3/6 Test: test_signature_comprehensive
Command: "/workspace/build-linux/test_signature_comprehensive"
Directory: /workspace/build-linux
"test_signature_comprehensive" start time: Feb 05 17:31 UTC
Output:
----------------------------------------------------------
TypeLayout Comprehensive Signature Audit

Platform: Linux 64-bit

========== Fundamental Integer Types ==========

[PASS] int8_t: [64-le]i8[s:1,a:1]
[PASS] uint8_t: [64-le]u8[s:1,a:1]
[PASS] int16_t: [64-le]i16[s:2,a:2]
[PASS] uint16_t: [64-le]u16[s:2,a:2]
[PASS] int32_t: [64-le]i32[s:4,a:4]
[PASS] uint32_t: [64-le]u32[s:4,a:4]
[PASS] int64_t: [64-le]i64[s:8,a:8]
[PASS] uint64_t: [64-le]u64[s:8,a:8]

========== Fundamental Float Types ==========

[INFO] float sizeof=4 alignof=4 sig=[64-le]f32[s:4,a:4]
[INFO] double sizeof=8 alignof=8 sig=[64-le]f64[s:8,a:8]
[INFO] long double sizeof=16 alignof=16 sig=[64-le]f80[s:16,a:16]

========== Character Types ==========

[PASS] char: [64-le]char[s:1,a:1]
[INFO] wchar_t sizeof=4 alignof=4 sig=[64-le]wchar[s:4,a:4]
[PASS] char8_t: [64-le]char8[s:1,a:1]
[PASS] char16_t: [64-le]char16[s:2,a:2]
[PASS] char32_t: [64-le]char32[s:4,a:4]

========== Boolean and Special Types ==========

[PASS] bool: [64-le]bool[s:1,a:1]
[PASS] std::byte: [64-le]byte[s:1,a:1]
[INFO] std::nullptr_t sizeof=8 alignof=8 sig=[64-le]nullptr[s:8,a:8]

========== Void Type ==========

[INFO] void is an incomplete type - no sizeof/alignof
[INFO] void* sizeof=8 alignof=8 sig=[64-le]ptr[s:8,a:8]
[INFO] void* sig: [64-le]ptr[s:8,a:8]
[INFO] int* sig: [64-le]ptr[s:8,a:8]
[PASS] void pointer type handled correctly

========== Pointer Types ==========

[INFO] int* sizeof=8 alignof=8 sig=[64-le]ptr[s:8,a:8]
[INFO] void* sizeof=8 alignof=8 sig=[64-le]ptr[s:8,a:8]
[INFO] const int* sizeof=8 alignof=8 sig=[64-le]ptr[s:8,a:8]
[INFO] int** sizeof=8 alignof=8 sig=[64-le]ptr[s:8,a:8]
[INFO] const void* const sizeof=8 alignof=8 sig=[64-le]ptr[s:8,a:8]

========== Function Pointer Types ==========

[INFO] FuncPtr1 sizeof=8 alignof=8 sig=[64-le]fnptr[s:8,a:8]
[INFO] FuncPtr2 sizeof=8 alignof=8 sig=[64-le]fnptr[s:8,a:8]
[INFO] FuncPtr3 sizeof=8 alignof=8 sig=[64-le]fnptr[s:8,a:8]
[INFO] FuncPtrNoexcept sizeof=8 alignof=8 sig=[64-le]fnptr[s:8,a:8]

========== Reference Types ==========

[INFO] int& sizeof=4 alignof=4 sig=[64-le]ref[s:8,a:8]
[INFO] int&& sizeof=4 alignof=4 sig=[64-le]rref[s:8,a:8]
[INFO] const int& sizeof=4 alignof=4 sig=[64-le]ref[s:8,a:8]

========== Member Pointer Types ==========

[INFO] DataMemberPtr sizeof=8 alignof=8 sig=[64-le]memptr[s:8,a:8]
[INFO] MethodPtr sizeof=16 alignof=8 sig=[64-le]memptr[s:16,a:8]

========== Array Types ==========

[INFO] int[10] sizeof=40 alignof=4 sig=[64-le]array[s:40,a:4]<i32[s:4,a:4],10>
[INFO] int[3][4] sizeof=48 alignof=4 sig=[64-le]array[s:48,a:4]<array[s:16,a:4]<i32[s:4,a:4],4>,3>
[INFO] char[100] sizeof=100 alignof=1 sig=[64-le]bytes[s:100,a:1]
[INFO] SimplePOD[5] sizeof=40 alignof=4 sig=[64-le]array[s:40,a:4]<struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]},5>

========== CV-Qualified Types ==========

[PASS] CV qualifiers correctly stripped
[INFO] int32_t signature: [64-le]i32[s:4,a:4]

========== User-Defined Structs ==========

[INFO] EmptyStruct sizeof=1 alignof=1 sig=[64-le]struct[s:1,a:1]{}
[INFO] SimplePOD sizeof=8 alignof=4 sig=[64-le]struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}
[INFO] NestedStruct sizeof=12 alignof=4 sig=[64-le]struct[s:12,a:4]{@0[inner]:struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]},@8[z]:i32[s:4,a:4]}
[INFO] WithPointer sizeof=16 alignof=8 sig=[64-le]struct[s:16,a:8]{@0[value]:i32[s:4,a:4],@8[ptr]:ptr[s:8,a:8]}

========== User-Defined Classes (with private members) ==========

[INFO] SimpleClass sizeof=8 alignof=4 sig=[64-le]struct[s:8,a:4]{@0[x_]:i32[s:4,a:4],@4[y_]:i32[s:4,a:4]}
[INFO] NestedClass sizeof=12 alignof=4 sig=[64-le]struct[s:12,a:4]{@0[inner_]:struct[s:8,a:4]{@0[x_]:i32[s:4,a:4],@4[y_]:i32[s:4,a:4]},@8[z_]:i32[s:4,a:4]}
[INFO] SimpleClass with private members: [64-le]struct[s:8,a:4]{@0[x_]:i32[s:4,a:4],@4[y_]:i32[s:4,a:4]}
[PASS] Class types with private members fully supported

========== Inheritance ==========

[INFO] Base sizeof=4 alignof=4 sig=[64-le]struct[s:4,a:4]{@0[base_val_]:i32[s:4,a:4]}
[INFO] DerivedSingle sizeof=8 alignof=4 sig=[64-le]class[s:8,a:4,inherited]{@0[base]:struct[s:4,a:4]{@0[base_val_]:i32[s:4,a:4]},@4[derived_val_]:i32[s:4,a:4]}
[INFO] Base2 sizeof=4 alignof=4 sig=[64-le]struct[s:4,a:4]{@0[base2_val_]:i32[s:4,a:4]}
[INFO] DerivedMultiple sizeof=12 alignof=4 sig=[64-le]class[s:12,a:4,inherited]{@0[base]:struct[s:4,a:4]{@0[base_val_]:i32[s:4,a:4]},@4[base]:struct[s:4,a:4]{@0[base2_val_]:i32[s:4,a:4]},@8[multi_val_]:i32[s:4,a:4]}

--- Virtual Inheritance ---
[INFO] VirtualBase sizeof=4 alignof=4 sig=[64-le]struct[s:4,a:4]{@0[vbase_val_]:i32[s:4,a:4]}
[INFO] DerivedVirtual sizeof=16 alignof=8 sig=[64-le]class[s:16,a:8,inherited]{@12[vbase]:struct[s:4,a:4]{@0[vbase_val_]:i32[s:4,a:4]},@8[vderived_val_]:i32[s:4,a:4]}

========== Polymorphic Classes ==========

[INFO] PolymorphicClass sizeof=16 alignof=8 sig=[64-le]class[s:16,a:8,polymorphic]{@8[poly_val_]:i32[s:4,a:4]}
[INFO] Polymorphic class size includes vtable pointer

========== Unions ==========

[INFO] SimpleUnion sizeof=4 alignof=4 sig=[64-le]union[s:4,a:4]{@0[i]:i32[s:4,a:4],@0[f]:f32[s:4,a:4],@0[c]:bytes[s:4,a:1]}

========== Enum Types ==========

[INFO] CStyleEnum sizeof=4 alignof=4 sig=[64-le]enum[s:4,a:4]<u32[s:4,a:4]>
[INFO] ScopedEnum sizeof=2 alignof=2 sig=[64-le]enum[s:2,a:2]<u16[s:2,a:2]>

========== Bit-fields ==========

[INFO] BitFieldStruct sizeof=4 alignof=4 sig=[64-le]struct[s:4,a:4]{@0.0[a]:bits<4,u32[s:4,a:4]>,@0.4[b]:bits<8,u32[s:4,a:4]>,@1.4[c]:bits<20,u32[s:4,a:4]>}
[INFO] BitFieldStruct signature: [64-le]struct[s:4,a:4]{@0.0[a]:bits<4,u32[s:4,a:4]>,@0.4[b]:bits<8,u32[s:4,a:4]>,@1.4[c]:bits<20,u32[s:4,a:4]>}

========== std::optional ==========

[INFO] std::optional<int> sizeof=8 alignof=4 sig=[64-le]class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:struct[s:8,a:4]{@0[<anon:0>]:union[s:4,a:4]{@0[__null_state_]:char[s:1,a:1],@0[__val_]:i32[s:4,a:4]},@4[__engaged_]:bool[s:1,a:1]}}}}}},@0[base]:struct[s:1,a:1]{},@0[base]:struct[s:1,a:1]{}}
[INFO] std::optional<SimplePOD> sizeof=12 alignof=4 sig=[64-le]class[s:12,a:4,inherited]{@0[base]:class[s:12,a:4,inherited]{@0[base]:class[s:12,a:4,inherited]{@0[base]:class[s:12,a:4,inherited]{@0[base]:class[s:12,a:4,inherited]{@0[base]:class[s:12,a:4,inherited]{@0[base]:struct[s:12,a:4]{@0[<anon:0>]:union[s:8,a:4]{@0[__null_state_]:char[s:1,a:1],@0[__val_]:struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}},@8[__engaged_]:bool[s:1,a:1]}}}}}},@0[base]:struct[s:1,a:1]{},@0[base]:struct[s:1,a:1]{}}
[PASS] std::optional signatures generated correctly

========== std::variant ==========

[INFO] VariantIntFloat sizeof=8 alignof=4 sig=[64-le]class[s:8,a:4,inherited]{@0[base]:struct[s:1,a:1]{},@0[base]:struct[s:1,a:1]{},@0[__impl_]:class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:struct[s:8,a:4]{@0[__data]:union[s:4,a:4]{@0[__dummy]:char[s:1,a:1],@0[__head]:struct[s:4,a:4]{@0[__value]:i32[s:4,a:4]},@0[__tail]:union[s:4,a:4]{@0[__dummy]:char[s:1,a:1],@0[__head]:struct[s:4,a:4]{@0[__value]:f32[s:4,a:4]},@0[__tail]:union[s:1,a:1]{}}},@4[__index]:u32[s:4,a:4]}}}}}}}}}}
[INFO] VariantIntDoubleChar sizeof=16 alignof=8 sig=[64-le]class[s:16,a:8,inherited]{@0[base]:struct[s:1,a:1]{},@0[base]:struct[s:1,a:1]{},@0[__impl_]:class[s:16,a:8,inherited]{@0[base]:class[s:16,a:8,inherited]{@0[base]:class[s:16,a:8,inherited]{@0[base]:class[s:16,a:8,inherited]{@0[base]:class[s:16,a:8,inherited]{@0[base]:class[s:16,a:8,inherited]{@0[base]:class[s:16,a:8,inherited]{@0[base]:class[s:16,a:8,inherited]{@0[base]:struct[s:16,a:8]{@0[__data]:union[s:8,a:8]{@0[__dummy]:char[s:1,a:1],@0[__head]:struct[s:4,a:4]{@0[__value]:i32[s:4,a:4]},@0[__tail]:union[s:8,a:8]{@0[__dummy]:char[s:1,a:1],@0[__head]:struct[s:8,a:8]{@0[__value]:f64[s:8,a:8]},@0[__tail]:union[s:1,a:1]{@0[__dummy]:char[s:1,a:1],@0[__head]:struct[s:1,a:1]{@0[__value]:char[s:1,a:1]},@0[__tail]:union[s:1,a:1]{}}}},@8[__index]:u32[s:4,a:4]}}}}}}}}}}
[PASS] std::variant signatures generated correctly

========== std::tuple ==========

[INFO] TupleInt sizeof=4 alignof=4 sig=[64-le]struct[s:4,a:4]{@0[__base_]:class[s:4,a:4,inherited]{@0[base]:struct[s:4,a:4]{@0[__value_]:i32[s:4,a:4]}}}
[INFO] TupleIntFloat sizeof=8 alignof=4 sig=[64-le]struct[s:8,a:4]{@0[__base_]:class[s:8,a:4,inherited]{@0[base]:struct[s:4,a:4]{@0[__value_]:i32[s:4,a:4]},@4[base]:struct[s:4,a:4]{@0[__value_]:f32[s:4,a:4]}}}
[INFO] TupleIntDoubleChar sizeof=24 alignof=8 sig=[64-le]struct[s:24,a:8]{@0[__base_]:class[s:24,a:8,inherited]{@0[base]:struct[s:4,a:4]{@0[__value_]:i32[s:4,a:4]},@8[base]:struct[s:8,a:8]{@0[__value_]:f64[s:8,a:8]},@16[base]:struct[s:1,a:1]{@0[__value_]:char[s:1,a:1]}}}

========== Edge Cases ==========

--- Anonymous Union ---
[INFO] WithAnonymousUnion sizeof=8 alignof=4 sig=[64-le]struct[s:8,a:4]{@0[header]:i32[s:4,a:4],@4[<anon:1>]:union[s:4,a:4]{@0[as_int]:i32[s:4,a:4],@0[as_float]:f32[s:4,a:4]}}
[PASS] Anonymous union member handled correctly with <anon:N> placeholder

--- [[no_unique_address]] ---
[INFO] NoUniqueAddressTest sizeof=4 alignof=4 sig=[64-le]struct[s:4,a:4]{@0[e1]:struct[s:1,a:1]{},@0[x]:i32[s:4,a:4],@0[e2]:struct[s:1,a:1]{}}
[INFO] Empty1 size: 1
[INFO] NoUniqueAddressTest should be <= sizeof(int32_t) + 2 bytes

--- alignas ---
[INFO] AlignedStruct sizeof=16 alignof=16 sig=[64-le]struct[s:16,a:16]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}

--- __attribute__((packed)) ---
[INFO] PackedStruct sizeof=6 alignof=1 sig=[64-le]struct[s:6,a:1]{@0[a]:char[s:1,a:1],@1[b]:i32[s:4,a:4],@5[c]:char[s:1,a:1]}
[INFO] PackedStruct without packing would be: 8 bytes (with padding)
[INFO] PackedStruct with packing should be: 6 bytes
[PASS] Packed struct correctly removes padding

========== Nested Template Types ==========

[INFO] WrapperInt sizeof=4 alignof=4 sig=[64-le]struct[s:4,a:4]{@0[value]:i32[s:4,a:4]}
[INFO] WrapperSimplePOD sizeof=8 alignof=4 sig=[64-le]struct[s:8,a:4]{@0[value]:struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}}
[INFO] PairIntFloat sizeof=8 alignof=4 sig=[64-le]struct[s:8,a:4]{@0[first]:i32[s:4,a:4],@4[second]:f32[s:4,a:4]}
[INFO] NestedWrapper sizeof=4 alignof=4 sig=[64-le]struct[s:4,a:4]{@0[value]:struct[s:4,a:4]{@0[value]:i32[s:4,a:4]}}
[PASS] Nested template types handled correctly

========== Signature Correctness Verification ==========

[INFO] LayoutA: [64-le]struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}
[INFO] LayoutB: [64-le]struct[s:8,a:4]{@0[a]:i32[s:4,a:4],@4[b]:i32[s:4,a:4]}
[PASS] Different layouts produce different signatures

========== AUDIT COMPLETE ==========
<end of output>
Test time =   0.01 sec
----------------------------------------------------------
Test Passed.
"test_signature_comprehensive" end time: Feb 05 17:31 UTC
"test_signature_comprehensive" time elapsed: 00:00:00
----------------------------------------------------------

4/6 Testing: test_anonymous_member
4/6 Test: test_anonymous_member
Command: "/workspace/build-linux/test_anonymous_member"
Directory: /workspace/build-linux
"test_anonymous_member" start time: Feb 05 17:31 UTC
Output:
----------------------------------------------------------
=== Anonymous Member Support Test ===

1. StructWithAnonUnion:
   Signature: [64-le]struct[s:12,a:4]{@0[x]:i32[s:4,a:4],@4[<anon:1>]:union[s:4,a:4]{@0[a]:i32[s:4,a:4],@0[b]:f32[s:4,a:4]},@8[y]:i32[s:4,a:4]}
   Expected: Contains '<anon:1>' for the anonymous union

2. StructWithAnonStruct:
   Signature: [64-le]struct[s:12,a:4]{@0[outer]:i32[s:4,a:4],@4[<anon:1>]:struct[s:8,a:4]{@0[inner_a]:i32[s:4,a:4],@4[inner_b]:f32[s:4,a:4]}}
   Expected: Contains '<anon:...>' for the anonymous struct

3. MultipleAnon:
   Signature: [64-le]struct[s:32,a:8]{@0[first]:i32[s:4,a:4],@4[<anon:1>]:union[s:2,a:2]{@0[c]:char[s:1,a:1],@0[s]:i16[s:2,a:2]},@8[middle]:i32[s:4,a:4],@16[<anon:3>]:union[s:8,a:8]{@0[d]:f64[s:8,a:8],@0[ll]:i64[s:8,a:8]},@24[last]:i32[s:4,a:4]}
   Expected: Contains '<anon:1>' and '<anon:3>' for the two unions

4. StructWithNamedUnion:
   Signature: [64-le]struct[s:12,a:4]{@0[x]:i32[s:4,a:4],@4[named]:union[s:4,a:4]{@0[a]:i32[s:4,a:4],@0[b]:f32[s:4,a:4]},@8[y]:i32[s:4,a:4]}
   Expected: Contains 'named' NOT '<anon:>'

5. std::optional<int>:
   Signature: [64-le]class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:struct[s:8,a:4]{@0[<anon:0>]:union[s:4,a:4]{@0[__null_state_]:char[s:1,a:1],@0[__val_]:i32[s:4,a:4]},@4[__engaged_]:bool[s:1,a:1]}}}}}},@0[base]:struct[s:1,a:1]{},@0[base]:struct[s:1,a:1]{}}
   Expected: Compiles without error!

6. std::variant<int, float>:
   Signature: [64-le]class[s:8,a:4,inherited]{@0[base]:struct[s:1,a:1]{},@0[base]:struct[s:1,a:1]{},@0[__impl_]:class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:class[s:8,a:4,inherited]{@0[base]:struct[s:8,a:4]{@0[__data]:union[s:4,a:4]{@0[__dummy]:char[s:1,a:1],@0[__head]:struct[s:4,a:4]{@0[__value]:i32[s:4,a:4]},@0[__tail]:union[s:4,a:4]{@0[__dummy]:char[s:1,a:1],@0[__head]:struct[s:4,a:4]{@0[__value]:f32[s:4,a:4]},@0[__tail]:union[s:1,a:1]{}}},@4[__index]:u32[s:4,a:4]}}}}}}}}}}
   Expected: Compiles without error!

=== All tests compiled successfully! ===
<end of output>
Test time =   0.01 sec
----------------------------------------------------------
Test Passed.
"test_anonymous_member" end time: Feb 05 17:31 UTC
"test_anonymous_member" time elapsed: 00:00:00
----------------------------------------------------------

5/6 Testing: test_alignment
5/6 Test: test_alignment
Command: "/workspace/build-linux/test_alignment"
Directory: /workspace/build-linux
"test_alignment" start time: Feb 05 17:31 UTC
Output:
----------------------------------------------------------
<end of output>
Test time =   0.01 sec
----------------------------------------------------------
Test Passed.
"test_alignment" end time: Feb 05 17:31 UTC
"test_alignment" time elapsed: 00:00:00
----------------------------------------------------------

6/6 Testing: test_user_defined_types
6/6 Test: test_user_defined_types
Command: "/workspace/build-linux/test_user_defined_types"
Directory: /workspace/build-linux
"test_user_defined_types" start time: Feb 05 17:31 UTC
Output:
----------------------------------------------------------
=======================================================
TypeLayout User-Defined Types Analysis
=======================================================

=== 1. Class Variants ===
EmptyClass: [64-le]struct[s:1,a:1]{}
  sizeof: 1, alignof: 1
EmptyClassC: [64-le]struct[s:1,a:1]{}
  sizeof: 1, alignof: 1
PODType: [64-le]struct[s:12,a:4]{@0[x]:i32[s:4,a:4],@4[y]:f32[s:4,a:4],@8[c]:char[s:1,a:1]}
  sizeof: 12, alignof: 4
StandardLayout: [64-le]struct[s:12,a:4]{@0[a]:i32[s:4,a:4],@4[b]:i32[s:4,a:4],@8[c]:i32[s:4,a:4]}
  sizeof: 12, alignof: 4
TriviallyCopyable: [64-le]struct[s:4,a:4]{@0[val]:i32[s:4,a:4]}
  sizeof: 4, alignof: 4
NonTrivialClass: [64-le]struct[s:4,a:4]{@0[value]:i32[s:4,a:4]}
  sizeof: 4, alignof: 4
AbstractClass: [64-le]class[s:16,a:8,polymorphic]{@8[data]:i32[s:4,a:4]}
  sizeof: 16, alignof: 8
FinalClass: [64-le]struct[s:4,a:4]{@0[val]:i32[s:4,a:4]}
  sizeof: 4, alignof: 4

  Type trait checks:
    PODType is_standard_layout: true
    TriviallyCopyable is_trivially_copyable: true
    NonTrivialClass is_trivially_copyable: false
    AbstractClass is_abstract: true
    FinalClass is_final: true

=== 2. Member Types ===
WithStatic: [64-le]struct[s:4,a:4]{@0[instance_val]:i32[s:4,a:4]}
  sizeof: 4, alignof: 4
  Note: static members should NOT appear in signature
WithConst: [64-le]struct[s:8,a:4]{@0[const_val]:i32[s:4,a:4],@4[normal_val]:i32[s:4,a:4]}
  sizeof: 8, alignof: 4
WithMutable: [64-le]struct[s:8,a:4]{@0[normal]:i32[s:4,a:4],@4[mutable_val]:i32[s:4,a:4]}
  sizeof: 8, alignof: 4
WithReference: [64-le]struct[s:16,a:8]{@0[ref]:ref[s:8,a:8],@8[const_ref]:ref[s:8,a:8]}
  sizeof: 16, alignof: 8
WithPointers: [64-le]struct[s:24,a:8]{@0[ptr]:ptr[s:8,a:8],@8[const_ptr]:ptr[s:8,a:8],@16[void_ptr]:ptr[s:8,a:8]}
  sizeof: 24, alignof: 8
WithArrays: [64-le]struct[s:80,a:8]{@0[arr1]:array[s:16,a:4]<i32[s:4,a:4],4>,@16[str]:bytes[s:16,a:1],@32[matrix]:array[s:48,a:8]<array[s:24,a:8]<f64[s:8,a:8],3>,2>}
  sizeof: 80, alignof: 8
WithBitfields: [64-le]struct[s:8,a:4]{@0[normal]:u32[s:4,a:4],@4.0[bf_a]:bits<3,u8[s:1,a:1]>,@4.3[bf_b]:bits<5,u8[s:1,a:1]>,@6.0[bf_c]:bits<10,u16[s:2,a:2]>,@7.2[bf_d]:bits<6,u16[s:2,a:2]>}
  sizeof: 8, alignof: 4

=== 3. Access Control ===
AllPublic: [64-le]struct[s:8,a:4]{@0[pub1]:i32[s:4,a:4],@4[pub2]:i32[s:4,a:4]}
  sizeof: 8, alignof: 4
WithProtected: [64-le]struct[s:8,a:4]{@0[prot_val]:i32[s:4,a:4],@4[pub_val]:i32[s:4,a:4]}
  sizeof: 8, alignof: 4
WithPrivate: [64-le]struct[s:12,a:4]{@0[priv1]:i32[s:4,a:4],@4[priv2]:i32[s:4,a:4],@8[pub1]:i32[s:4,a:4]}
  sizeof: 12, alignof: 4
MixedAccess: [64-le]struct[s:16,a:4]{@0[pub1]:i32[s:4,a:4],@4[prot1]:i32[s:4,a:4],@8[priv1]:i32[s:4,a:4],@12[pub2]:i32[s:4,a:4]}
  sizeof: 16, alignof: 4
  Note: P2996 uses access_context::unchecked() to access all members

=== 4. Template Types ===
SimpleTemplate<int32_t>: [64-le]struct[s:8,a:4]{@0[value]:i32[s:4,a:4],@4[count]:i32[s:4,a:4]}
  sizeof: 8, alignof: 4
SimpleTemplate<double>: [64-le]struct[s:16,a:8]{@0[value]:f64[s:8,a:8],@8[count]:i32[s:4,a:4]}
  sizeof: 16, alignof: 8
SimpleTemplate<bool>: [64-le]struct[s:8,a:4]{@0[flag]:u8[s:1,a:1],@4[count]:i32[s:4,a:4]}
  sizeof: 8, alignof: 4
SimpleTemplate<int32_t*>: [64-le]struct[s:16,a:8]{@0[ptr]:ptr[s:8,a:8],@8[size]:u64[s:8,a:8]}
  sizeof: 16, alignof: 8
Variadic2: [64-le]struct[s:16,a:8]{@0[data]:struct[s:16,a:8]{@0[__base_]:class[s:16,a:8,inherited]{@0[base]:struct[s:4,a:4]{@0[__value_]:i32[s:4,a:4]},@8[base]:struct[s:8,a:8]{@0[__value_]:f64[s:8,a:8]}}}}
  sizeof: 16, alignof: 8
Variadic3: [64-le]struct[s:12,a:4]{@0[data]:struct[s:12,a:4]{@0[__base_]:class[s:12,a:4,inherited]{@0[base]:struct[s:1,a:1]{@0[__value_]:char[s:1,a:1]},@4[base]:struct[s:4,a:4]{@0[__value_]:i32[s:4,a:4]},@8[base]:struct[s:4,a:4]{@0[__value_]:f32[s:4,a:4]}}}}
  sizeof: 12, alignof: 4
CRTPDerived: [64-le]class[s:8,a:4,inherited]{@0[base]:struct[s:4,a:4]{@0[base_val]:i32[s:4,a:4]},@4[derived_val]:i32[s:4,a:4]}
  sizeof: 8, alignof: 4

=== 5. Nested Types ===
Outer1: [64-le]struct[s:12,a:4]{@0[nested]:struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]},@8[outer_val]:i32[s:4,a:4]}
  sizeof: 12, alignof: 4
Outer1::Inner: [64-le]struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}
  sizeof: 8, alignof: 4
OuterClass: [64-le]struct[s:16,a:8]{@0[inner]:struct[s:8,a:8]{@0[val]:f64[s:8,a:8]},@8[outer_val]:i32[s:4,a:4]}
  sizeof: 16, alignof: 8
OuterClass::InnerClass: [64-le]struct[s:8,a:8]{@0[val]:f64[s:8,a:8]}
  sizeof: 8, alignof: 8
WithNestedEnum: [64-le]struct[s:8,a:4]{@0[status]:enum[s:1,a:1]<u8[s:1,a:1]>,@4[code]:i32[s:4,a:4]}
  sizeof: 8, alignof: 4
WithNestedUnion: [64-le]struct[s:8,a:4]{@0[data]:union[s:4,a:4]{@0[i]:i32[s:4,a:4],@0[f]:f32[s:4,a:4]},@4[type_tag]:u8[s:1,a:1]}
  sizeof: 8, alignof: 4
WithNestedUnion::Data: [64-le]union[s:4,a:4]{@0[i]:i32[s:4,a:4],@0[f]:f32[s:4,a:4]}
  sizeof: 4, alignof: 4
WithAnonymous: [64-le]struct[s:12,a:4]{@0[<anon:0>]:struct[s:8,a:4]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]},@8[z]:i32[s:4,a:4]}
  sizeof: 12, alignof: 4

=== 6. Inheritance ===
SingleBase: [64-le]struct[s:4,a:4]{@0[base_val]:i32[s:4,a:4]}
  sizeof: 4, alignof: 4
SingleDerived: [64-le]class[s:8,a:4,inherited]{@0[base]:struct[s:4,a:4]{@0[base_val]:i32[s:4,a:4]},@4[derived_val]:i32[s:4,a:4]}
  sizeof: 8, alignof: 4
MultiInherit: [64-le]class[s:12,a:4,inherited]{@0[base]:struct[s:4,a:4]{@0[a]:i32[s:4,a:4]},@4[base]:struct[s:4,a:4]{@0[b]:i32[s:4,a:4]},@8[own]:i32[s:4,a:4]}
  sizeof: 12, alignof: 4
VirtualDerived1: [64-le]class[s:24,a:8,inherited]{@16[vbase]:struct[s:8,a:8]{@0[vb_val]:i64[s:8,a:8]},@8[vd1]:i32[s:4,a:4]}
  sizeof: 24, alignof: 8
DiamondFinal: [64-le]class[s:40,a:8,inherited]{@0[base]:class[s:24,a:8,inherited]{@16[vbase]:struct[s:8,a:8]{@0[vb_val]:i64[s:8,a:8]},@8[vd1]:i32[s:4,a:4]},@16[base]:class[s:24,a:8,inherited]{@16[vbase]:struct[s:8,a:8]{@0[vb_val]:i64[s:8,a:8]},@8[vd2]:i32[s:4,a:4]},@28[diamond_val]:i32[s:4,a:4]}
  sizeof: 40, alignof: 8
PrivatelyInherited: [64-le]class[s:8,a:4,inherited]{@0[base]:struct[s:4,a:4]{@0[base_val]:i32[s:4,a:4]},@4[derived_val]:i32[s:4,a:4]}
  sizeof: 8, alignof: 4
ProtectedInherited: [64-le]class[s:8,a:4,inherited]{@0[base]:struct[s:4,a:4]{@0[base_val]:i32[s:4,a:4]},@4[derived_val]:i32[s:4,a:4]}
  sizeof: 8, alignof: 4

=== 7. Special Cases ===
EBO test:
  sizeof(EmptyBase1) = 1
  sizeof(EBOChild) = 4 (should be 4 with EBO)
EBOChild: [64-le]class[s:4,a:4,inherited]{@0[base]:struct[s:1,a:1]{},@0[val]:i32[s:4,a:4]}
  sizeof: 4, alignof: 4

[[no_unique_address]] test:
  sizeof(WithNoUniqueAddr) = 4 (should be 4 with NUA)
WithNoUniqueAddr: [64-le]struct[s:4,a:4]{@0[empty]:struct[s:1,a:1]{},@0[val]:i32[s:4,a:4]}
  sizeof: 4, alignof: 4

aligns test:
  alignof(Aligned16Struct) = 16 (should be 16)
  alignof(CacheLineAligned) = 64 (should be 64)
Aligned16Struct: [64-le]struct[s:16,a:16]{@0[x]:i32[s:4,a:4],@4[y]:i32[s:4,a:4]}
  sizeof: 16, alignof: 16
CacheLineAligned: [64-le]struct[s:64,a:64]{@0[data]:array[s:16,a:4]<i32[s:4,a:4],4>}
  sizeof: 64, alignof: 64

Packed struct test:
  sizeof(PackedStruct) = 6 (should be 6 if packed)
PackedStruct: [64-le]struct[s:6,a:1]{@0[c]:char[s:1,a:1],@1[i]:i32[s:4,a:4],@5[c2]:char[s:1,a:1]}
  sizeof: 6, alignof: 1
HasUnionMember: [64-le]struct[s:8,a:4]{@0[value]:union[s:4,a:4]{@0[as_int]:i32[s:4,a:4],@0[as_float]:f32[s:4,a:4]},@4[type]:u8[s:1,a:1]}
  sizeof: 8, alignof: 4

=======================================================
Analysis Complete!
=======================================================
<end of output>
Test time =   0.02 sec
----------------------------------------------------------
Test Passed.
"test_user_defined_types" end time: Feb 05 17:31 UTC
"test_user_defined_types" time elapsed: 00:00:00
----------------------------------------------------------

End testing: Feb 05 17:31 UTC

core =   0.08 sec*proc

